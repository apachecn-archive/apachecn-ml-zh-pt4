第九章

![image](../images/00004.jpeg)

结论

你读完了这本书——祝贺你！这是一次漫长的旅程，我希望它也是一次愉快的旅程——一路上你从中获得了一两个想法。在我们分道扬镳之前，我想回顾一下我们共同取得的成就可能是值得的，也许还可以看看是否有一些更广泛的主题适用于各个章节，尽管它们有着深刻的差异。

绘制我们的旅程

我写这本书的目的是以一种既容易理解又有趣的方式介绍机器学习的主题。NET 开发人员。机器学习是一个很大的话题，它理所当然地每天都吸引着更多的关注。这也是一个经常以有点抽象的方式出现的话题，导致许多人认为这是一个复杂的话题，最好留给数学家去解决。

虽然数学在机器学习中扮演着重要的角色，但我希望在读完这本书后，你会意识到它并不像听起来那么复杂，许多潜在的想法实际上相当简单，并适用于广泛的实际问题。

让我们后退一步，看看我们走过的路。在很高的层面上，我们建立了类似机器学习问题地图的东西，做出了重要的区分。首先，我们介绍了监督和非监督方法。每一个都解决了一个不同的问题，如下:

*   **无监督方法**是当你还不知道你可能在寻找什么问题时，帮助你理解数据。这是第五章[的主要话题，在那里我们收集了一组 StackOverflow 问题，并简单地寻找有助于我们理解难以解释的非结构化数据的模式。](5.html#BE6O0-841455c729754b8aac560d608a86cf91)
*   相比之下，**监督方法**，在这里我们花了大部分精力([第 1 章](1.html#7K4G0-841455c729754b8aac560d608a86cf91)，2，4，6)，是关于训练一个模型来回答一个定义明确的问题，这个问题对我们来说是基于标记的例子；即正确答案已知的数据。

在那次探索中，我们涵盖了大量具有重要差异的模型。首先，我们区分了分类模型和回归模型，这两种模型的答案类型不同。**回归**模型旨在预测一个连续的数值；在第 4 章的[中，我们开发了这样一个模型，根据各种输入来预测自行车共享服务的使用水平。相比之下，**分类**模型是关于在有限数量的可能结果中决定哪一个是最有可能的。我们看到了这种模型的三个例子，从自动识别图像代表的十个可能数字中的哪一个(](4.html#AFM60-841455c729754b8aac560d608a86cf91)[第一章](1.html#7K4G0-841455c729754b8aac560d608a86cf91))，到区分火腿和垃圾短信([第二章](2.html#8IL20-841455c729754b8aac560d608a86cf91))，以及预测泰坦尼克号上的哪些乘客将在旅行中幸存([第六章](6.html#CCNA0-841455c729754b8aac560d608a86cf91))。

我们还在第 7 章中探索了一种使用强化学习的不同方法。由此产生的模型是一个在有限的一组可能的行动之间做出决定的分类器，与以前的模型有一个关键的区别:我们不是使用过去的数据学习一次，而是建立一个随着新的观察结果的出现而不断学习的模型，这种方法通常被称为的**在线学习**。

在整本书中，我们挖掘了各种真实的数据集，并让数据指导我们的探索。尽管表面上主题多种多样(图像、文本、数字等等)，问题中还是出现了一些模式。在大多数情况下，我们最终应用了**特征提取**——我们将原始数据转换成更多信息或更便于处理的值行。而且，正如我们在模型中寻找的答案类型决定了是分类还是回归更合适，我们最终会根据特征是连续的还是分类的而采用不同的方法。我们还看到了如何通过宁滨将一个连续的特征转化为一个离散的特征(在泰坦尼克号的例子中是年龄)，或者相反地，如何将一个分类变量转化为一系列指示变量(在回归的例子中是星期几)。

科学！

我们在章节中看到的另一个模式涉及方法论。我们从一个我们想要回答的问题开始，我们收集所有可用的数据，开始进行一系列的实验，逐步创建和完善一个符合事实的模型。

从这个意义上说，开发机器学习模型与开发常规的业务线应用程序有很大的不同。当您构建一个应用程序时，您通常有一组要实现的功能；每个特性都有某种形式的验收标准，描述了完成它所需要的条件。开发人员将问题分解成更小的代码片段，将它们放在一起，一旦事情按预期一起工作，任务就完成了。

相比之下，开发机器学习程序更接近于遵循科学方法的研究活动。你事先不知道一个特定的想法是否可行。你必须制定一个理论，使用你现有的数据建立一个预测模型，然后验证你建立的模型是否符合数据。这有点棘手，因为很难估计开发这样一个模型可能需要多长时间。你可以尝试一个非常简单的想法，并在半天内完成，或者你可以花几个星期，但除了失败的实验外，你的工作没有任何成果。

当然，事情并不完全明朗。在开发一个常规的应用程序时，会有一些不确定性，也会有一些失败的实验。然而，事实仍然是，通过机器学习，你不会知道你的想法是否可行，直到你用数据面对你的模型。也就是说，一些软件工程的想法仍然适用，尽管是以一种稍微修改的方式。

就像对你要发布的功能有一个清晰的说明会有所帮助一样，尽早考虑如何衡量成功，然后为此做好准备也是至关重要的。正确的代码只是一个好的机器学习模型的一小部分；要有价值，一个模型必须有用，这意味着它必须善于做出预测。在这个框架中，我们在整本书中反复使用了**交叉验证**。将您的部分数据放在一边，不要将其用于训练，一旦您准备好模型，请测试它在验证集上的工作情况，该验证集模拟当您的模型在真实条件下看到新输入时可能会发生的情况。在某些方面，交叉验证的目的类似于常规代码的测试套件，允许您检查事情是否按预期进行。

对于机器学习和软件开发来说，我有一个很好的习惯，那就是尽快建立一个工作原型。在机器学习的背景下，这意味着创建你能想到的最天真和快速执行的模型。这有很多好处:它迫使您将从数据到验证的端到端过程组合在一起，您可以在进行过程中重用和改进这些过程。它有助于及早发现潜在的问题。它建立了一个基线，一个设定标准来判断其他模型是好是坏的数字。最后，如果你幸运的话，这个简单的模型可能会工作得很好，在这种情况下，你可以早点完成。

说到简单的模型，有一点我真的希望我能在本书中讲清楚。围绕机器学习的许多讨论都强调了奇特的模型和技术。复杂的算法很有趣，但最终，花时间理解数据和提取正确的特征通常更重要。给一个复杂的算法输入糟糕的数据不会神奇地产生好的答案。相反，正如我们在几章中看到的，使用精心制作的功能的非常简单的模型可以产生令人惊讶的好结果。另外，更简单的模型也更容易理解。

F#:以实用的方式高效工作

我们一起写的绝大部分代码都是用 F#写的，功能优先。网语。如果这是您第一次接触 F#，我希望您喜欢它，并且它将激励您进一步探索它！在某种程度上，函数式编程遇到了类似于机器学习的问题；也就是说，它经常被描述为一个理论性和抽象的话题。在过去的几年里，F#成为我的主要语言的原因与理论无关。我发现它是一种非常高效的语言。我可以用简单明了的代码表达想法，并快速提炼，更快地完成工作。另外，我只是觉得使用这种语言很有趣。

在我看来，F#品质在应用到机器学习这个话题上时大放异彩。首先，内置的脚本环境和一种语法简洁、富于表现力的语言至关重要。开发一个机器学习模型需要大量的探索和实验，能够加载一次数据并全天继续探索，而没有必须重新加载和重新编译的潜在干扰，这是关键。

然后，如果你回顾我们一起建立的模型，你可能会注意到一个一般的模式。从一个数据源开始，我们读取它并提取特征，我们应用一个学习过程来更新模型，直到拟合足够好，我们计算一些带有交叉验证的质量度量。这种通用流程与函数式风格非常匹配，我们的实现在问题上看起来非常相似:应用地图将数据转换为特征，使用递归应用模型更新和学习，使用平均值或折叠将预测缩减为质量指标，如准确性。函数式语言的词汇非常自然地符合机器学习所追求的问题类型。另外，强调不可变数据的函数模式更容易并行化，这在处理大量数据时很方便。

虽然这一点也适用于其他函数式语言，但 F#有几个特点使它特别有趣。第一个是类型提供者，我们在第三章的[中探讨过的一种机制。大多数语言要么是动态类型的，要么是静态类型的，每种语言都有其优势或挑战。要么外部数据很容易访问，但我们从编译器那里得到的帮助有限，要么相反。F#类型提供者为这种紧张提供了一种解决方案，使数据(或语言，如我们的例子中调用 R 语言)以非常有限的摩擦被消费，并以一种安全的方式被发现，具有静态类型的所有好处。](3.html#9H5K0-841455c729754b8aac560d608a86cf91)

F#对于该特定领域的另一个独特优势是它既可以用于勘探，也可以用于生产。在本书中，我们主要关注第一个方面，在快速反馈循环中探索数据，并逐步完善模型。然而，一旦想法变得稳定，将代码从一个脚本提升到一个模块或一个类，并把它变成一个成熟的库是相当琐碎的，正如两三章中所阐述的。您可以期待与您相同的性能水平。NET 总的来说——也就是说，相当不错。此时，您可以在生产环境中运行该代码，并将其与. NET 代码库集成，无论该代码是用 C#、VB.NET 还是 F#编写的。从勘探到生产，能够使用同一种语言是有实际价值的。我在很多地方看到过这样一个开发过程，其中一个研究团队使用一套工具和语言创建模型，并将其转移给一个开发团队，该团队要么全部重写(伴随着所有的问题),要么尽最大努力将外来工具集成并运行到生产系统中。F#可以为这种紧张提供一个有趣的解决方案，既可以作为研究的探索性语言，也可以作为开发人员的生产就绪语言。

下一步是什么？

那么，你现在是机器学习专家吗？如果这让你感到失望，我很抱歉，但是这本书仅仅触及了皮毛，还有很多很多东西需要学习。话虽如此，如果你喜欢这个话题，好消息是你不会缺乏有趣的学习材料(作为起点，我建议你看看吴恩达在 Coursera 上的课程，并尝试一些 Kaggle 竞赛)。机器学习发展迅速，这也是我如此喜欢这个领域的原因之一。

也许更重要的是，你可能还不是专家——但是，很少有人是专家，因为这个话题太大了。然而，在这一点上，你可能比大多数软件工程师更了解这个主题，并且你应该能够在你自己的项目中有效地使用我们一起讨论过的一些想法。最重要的是，我希望我成功地让你相信，机器学习并不像一开始看起来那么复杂，对数学家和软件工程师来说，它充满了真正有趣的问题，而且非常有趣。所以，去试试吧，做伟大的事情，玩得开心！