# 6.在 OBIEE 12c 中实现机器学习

第 [3 章](3.html)强调了机器学习模型的使用，即`randomForest`算法，以预测葡萄酒原产地的商业用例为例，将其结果与 OBIEE 12c 集成。它解释了如何使用 R 和 Oracle R Enterprise (ORE)实现这一点，然后将其图形输出与 OBIEE 仪表板集成以实现 BI 目的。第 [5 章](5.html)讨论了在 OBIEE 中利用机器学习来帮助构建决策支持解决方案的其他业务用例。其中一个扩展了葡萄酒产地预测用例，根据葡萄酒的产地来预测购买倾向。这种现实世界的决策支持解决方案在提供更好的业务成果和业务价值方面大有可为，并提高了企业竞争情报的标准。

本章重点介绍如何通过在 Oracle 12c 中使用基于 R 和基于 ORE 的算法来构建模型并对模型进行评分，然后以可视化方式或其他方式将输出结果整合到 OBIEE 12c 中，从而实现上述业务案例。最后，它描述了通过基于用户的动态输入，基于机器学习输出构建交互式仪表板的步骤。

## 业务用例问题描述和解决方案

葡萄酒产地预测用例根据每种葡萄酒的类别和其他属性将葡萄酒的产地分为`Origin1`、`Origin2`或`Origin3`。根据产地，手头的问题是预测购买特定葡萄酒的倾向。后者是作为与葡萄酒产地相关的结果的真实世界业务问题的四个示例用例之一提出的。这在第 [5 章](5.html)中有所强调，以及使用机器学习和/或基于 OBIEE 的功能解决每个问题的方法。

### 技术上来说

从数据科学的角度分析前面的业务用例，预测购买倾向的问题具有 1 或 0 的二元结果。结果 1 表示客户将从该来源购买葡萄酒，0 表示客户不会购买该葡萄酒。虽然这听起来像是一个分类问题，但事实上更有意义的是，根据葡萄酒的产地，将这视为对客户是否会购买特定葡萄酒的概率的预测。

使用 R 和 ORE 可以解决这个问题，本章将深入讨论它们。在我们深入研究其中的编程和图形部分之前，我们将讨论用于解决这种预测的机器学习算法背后的基础——也就是说，它涉及概率的二元结果。这需要对要构建的模型背后的数学概念进行一些解释，并对模型的预测输出进行评分。

Note

在众多可用的机器学习算法中，最适用于预测概率(二元结果)的是广义线性模型，也称为逻辑回归。它输出介于 0 和 1 之间的概率值，因此在预测方面是准确的。对此问题使用线性模型(如线性回归)可能会导致预测概率低于 0 或高于 1。相比之下，逻辑回归结果被限制在有界集合[0，1]中，该集合不是实际值而是概率值，因此可以直接这样解释。

### 解决方案的第一部分

我们用例中的葡萄酒`Source`变量被称为分类变量`,`，购买倾向被称为响应变量。我们使用逻辑回归的机器学习模型预测了 0 到 1 之间的概率，通过使用特定的阈值，可以将其转换为二进制响应。比如，如果 p > = 0.5，那么概率为 1；否则为 0，其中 p 为预测概率值。

清单 [6-1](#Par9) 显示了预测葡萄酒来源的代码(类似于第 [3 章](3.html)中的清单)。它使用`ore.randomForest`机器学习算法来预测葡萄酒产地，并将列名`Source`分配给预测的产地列。

```
library(ORE)
ore.connect("testr","orcl","localhost","testr")
library(OREmodels)
winedata <- read.csv("winedata.csv", header=TRUE, row.names = NULL, sep=',')
head(winedata)
winedata$origin <- ifelse(winedata$class == 1, 'Origin1',
ifelse(winedata$class == 2, 'Origin2',
ifelse(winedata$class == 3, 'Origin3', '')))
class(winedata$origin)
winedata$origin <- as.factor(winedata$origin)
class(winedata$origin)
head(winedata$origin)
table(winedata$origin)
set.seed(123)
sample_size <- 0.70 * nrow(winedata)
sampledata <-sample(seq_len(nrow(winedata)), sample_size)
training_data <- winedata[sampledata, ]
class(training_data)
TRAINING_DATA <- ore.push(training_data)
class(TRAINING_DATA)
test_data <- winedata[-sampledata, ]
TEST_DATA <- ore.push(test_data)
class(TEST_DATA)
head(TRAINING_DATA)
head(TEST_DATA) 

wine.rf <- ore.randomForest(origin ∼ . - class, TRAINING_DATA)

class(wine.rf)
tree15 = grabTree(wine.rf, k = 15, labelVar = TRUE)
origin_pred <- predict(wine.rf, TEST_DATA, type = "all", supplemental.cols="origin")
res <- table(origin_pred$origin, origin_pred$prediction)
library(AppliedPredictiveModeling)
transparentTheme(trans = .4)
pairs(table(origin_pred$origin, origin_pred$prediction), main="Wine Origin Predictors")
test_data$id <- seq_len(nrow(test_data))
row.names(test_data) <- test_data$id
head(test_data[,c(16,1,15)]) 

origin_pred2 <- ore.pull(origin_pred)
origin_pred2$id <- seq_len(nrow(origin_pred2))
head(origin_pred2)
row.names(origin_pred2) <- origin_pred2$id
head(test_data)
head(origin_pred2)
head(origin_pred2[,c(6,5,4)])
df1 <- test_data[,c(16,15,1:14)]
df2 <- origin_pred2[, c(1:6)]
class(df1)
df1_new <- df1[order(df1$origin),]
head(df1_new)
df2_new <- df2[order(df2$origin),]
head(df2_new)
nrow(df1_new)
nrow(df2_new)
data_set <- data.frame(df1_new, df2_new)
nrow(data_set)
head(data_set)

colnames(data_set)[20] <- "Source"

head(data_set)

data_set$propensity_to_buy <- ifelse((data_set$Source == 'Origin1'), 1,

ifelse((data_set$Source == 'Origin2'), 0,

ifelse((data_set$Source == 'Origin3'), 1, '')))

class(data_set)
nrow(data_set)
head(data_set)
write.csv(data_set, "Wineptobuy.csv", row.names=FALSE) 

Listing 6-1.Using ore.randomForest to Predict Wine Origin

```

这里显示了清单 [6-1](#Par9) 的输出，并插入了注释来解释代码:

```
> library(ORE)  # load the ORE library, which is the primary library for # Oracle R Enterprise execution

Loading required package: OREbase
Loading required package: OREcommon

Attaching package: 'OREbase'

The following objects are masked from 'package:base':

    cbind, data.frame, eval, interaction, order, paste, pmax, pmin,
    rbind, table

Loading required package: OREembed
Loading required package: OREstats
Loading required package: MASS
Loading required package: OREgraphics
Loading required package: OREeda
Loading required package: OREmodels
Loading required package: OREdm
Loading required package: lattice
Loading required package: OREpredict
Loading required package: ORExml
> ore.connect("testr","orcl","localhost","testr") # connect to DB by calling # ore.connect

> library(OREmodels) # load the OREmodels library for calling ORE machine # learning model(s)

> winedata <- read.csv("winedata.csv", header=TRUE, row.names = NULL, sep=',') # Read input data from .csv file into a data.frame R object

> head(winedata) # Display 6 rows in the input data frame. This displays the # various columns which includes predictor variable(s), 
attributes

  class Alcohol Malic.acid  Ash Alcanility.of.ash Magnesium Total.phenols
1     1   14.23       1.71 2.43              15.6       127          2.80
2     1   13.20       1.78 2.14              11.2       100          2.65
3     1   13.16       2.36 2.67              18.6       101          2.80
4     1   14.37       1.95 2.50              16.8       113          3.85
5     1   13.24       2.59 2.87              21.0       118          2.80
6     1   14.20       1.76 2.45              15.2       112          3.27
  Flavanoids Nonflavanoid.phenols Proanthocyanins Color.intensity    Hue
1       3.06                 0.28            2.29            5.64    1.04
2       2.76                 0.26            1.28            4.38    1.05
3       3.24                 0.30            2.81            5.68    1.03
4       3.49                 0.24            2.18            7.80    0.86
5       2.69                 0.39            1.82            4.32    1.04
6       3.39                 0.34            1.97            6.75    1.05
  OD280.OD315.of.diluted.wines Proline

1                         3.92    1065
2                         3.40    1050
3                         3.17    1185
4                         3.45    1480
5                         2.93     735
6                         2.85    1450
> winedata$origin <- ifelse(winedata$class == 1, 'Origin1', # Create a # origin column in the winedata data frame based on 'class' predictor

+ ifelse(winedata$class == 2, 'Origin2',
+ ifelse(winedata$class == 3, 'Origin3', '')))
> class(winedata$origin) # Display the R class of the newly created 'origin' # column

[1] "character"

> winedata$origin <- as.factor(winedata$origin) # Convert 'origin' into a # categorical variable by applying the factor() R function

> class(winedata$origin) # Display the R class of the converted 'origin' # column

[1] "factor"
> head(winedata$origin) # Displays number of distinct classes for 'origin' # as levels of the 'origin' predictor

[1] Origin1 Origin1 Origin1 Origin1 Origin1 Origin1
Levels: Origin1 Origin2 Origin3
> table(winedata$origin) # Display count of each distinct 'origin' value

Origin1 Origin2 Origin3
    489     549     336
> set.seed(123) # set the seed for sampling the input winedata data set

> sample_size <- 0.70 * nrow(winedata) # set the sample size for sampling # the winedata data set. Here we use a sample size of 70%

> sampledata <-sample(seq_len(nrow(winedata)), sample_size) # Randomly # sample the winedata based on the sample size set above

> training_data <- winedata[sampledata, ] # Split the winedata data set into # training_data containing 70% of the samples

> class(training_data) # Display the R class for training_data

[1] "data.frame"
> TRAINING_DATA <- ore.push(training_data) # Store the training_data in the # DB in an ore.frame object callexd TRAINING_DATA

> class(TRAINING_DATA)
[1] "ore.frame"
attr(,"package")
[1] "OREbase"
> test_data <- winedata[-sampledata, ] # Create a test_data set in R that # contains the reamining data in the same 
set

> TEST_DATA <- ore.push(test_data) # Store the test_data in the DB in an # ore.frame object called TEST_DATA

> class(TEST_DATA)
[1] "ore.frame"
attr(,"package")
[1] "OREbase"
> head(TRAINING_DATA) # Display 6 rows of the TRAINING_DATA data set. Notice # that it contains an additional 'origin' column

     class Alcohol Malic.acid  Ash Alcanility.of.ash Magnesium Total.phenols
396      3   12.60       2.46 2.20              18.5        94          1.62
1083     3   13.45       3.70 2.60              23.0       111          1.70
562      2   11.82       1.72 1.88              19.5        86          2.50
1211     2   11.82       1.47 1.99              20.8        86          1.98
1289     3   12.70       3.55 2.36              21.5       106          1.70
63       2   13.67       1.25 1.92              18.0        94          2.10
     Flavanoids Nonflavanoid.phenols Proanthocyanins Color.intensity    Hue

396        0.66                 0.63            0.94            7.10   0.73
1083       0.92                 0.43            1.46           10.68   0.85
562        1.64                 0.37            1.42            2.06   0.94
1211       1.60                 0.30            1.53            1.95   0.95
1289       1.20                 0.17            0.84            5.00   0.78
63         1.79                 0.32            0.73            3.80   1.23
     OD280.OD315.of.diluted.wines Proline  origin
396                          1.58     695 Origin3
1083                         1.56     695 Origin3
562                          2.44     415 Origin2
1211                         3.33     495 Origin2
1289                         1.29     600 Origin3
63                           2.46     630 Origin2 # This too contains an # additional column 'origin'

> head(TEST_DATA) # Display 6 rows of the TEST_DATA data set

   class Alcohol Malic.acid  Ash Alcanility.of.ash Magnesium Total.phenols

4      1   14.37       1.95 2.50              16.8       113          3.85
6      1   14.20       1.76 2.45              15.2       112          3.27
8      1   14.06       2.15 2.61              17.6       121          2.60
20     1   13.64       3.10 2.56              15.2       116          2.70
21     1   14.06       1.63 2.28              16.0       126          3.00
24     1   12.85       1.60 2.52              17.8        95          2.48
   Flavanoids Nonflavanoid.phenols Proanthocyanins Color.intensity  Hue
4        3.49                 0.24            2.18            7.80 0.86
6        3.39                 0.34            1.97            6.75 1.05
8        2.51                 0.31            1.25            5.05 1.06
20       3.03                 0.17            1.66            5.10 0.96
21       3.17                 0.24            2.10            5.65 1.09
24       2.37                 0.26            1.46            3.93 1.09
   OD280.OD315.of.diluted.wines Proline  origin

4                          3.45    1480 Origin1
6                          2.85    1450 Origin1
8                          3.58    1295 Origin1
20                         3.36     845 Origin1
21                         3.71     780 Origin1
24                         3.63    1015 Origin1

```

输出的下一部分显示了通过使用`class`作为预测变量和`origin`作为响应变量调用`ore.randomForest()`函数并处理`TRAINING_DATA`数据集来构建随机森林模型。它生成特定数量的决策树，对它们的输出进行平均，并使用这些信息。来进行分类。

```
> wine.rf <- ore.randomForest(origin ∼ . - class, TRAINING_DATA)
> class(wine.rf) # Display the class of the object returned by the build # model. It is of class "ore.model"

[1] "ore.randomForest" "ore.model"

# grabTree() extracts a particular decision tree and k represents which tree # to use. labelVar set to TRUE means the 'split var' and

# 'prediction' columns in the output frame are assigned meaningful labels.

> tree15 = grabTree(wine.rf, k = 15, labelVar = TRUE)

# Score the built model on TEST_DATA by calling predict(). type="all" # specifies that both predicted values and matrix of vote counts are

# returned in the output. supplemental.cols="origin" specifies that the # 'origin' column from the TEST_DATA data set must be included in the

# predicted

results

> origin_pred <- predict(wine.rf, TEST_DATA, type = "all", supplemental.cols="$

# Outputs a table of counts for 'origin' levels, namely, Origin1, Origin2, # Origin3 and the actual response prediction, and stores it in

# a 'res' object

> res <- table(origin_pred$origin, origin_pred$prediction
> library(AppliedPredictiveModeling)
Warning message:
package 'AppliedPredictiveModeling' was built under R version 3.2.5
> transparentTheme(trans = .4)

# Plots a pairs plot of the above table with heading 'Wine Origin # Predictors'

> pairs(table(origin_pred$origin, origin_pred$prediction), main="Wine Origin P$

# Create a new column id and assign it to each row of the test_data data # set. Seq_len() creates a sequence upto count of rows in test_data

> test_data$id <- seq_len(nrow(test_data))
> row.names(test_data) <- test_data$id # Assigns the id column for each row # with the corresponding value of the sequence created for id

> head(test_data[,c(16,1,15)]) # Display the 16th, 1st, and 15th columns for # 6 rows in test_data with ids 1 to 6

  id class  origin

1  1     1 Origin1
2  2     1 Origin1
3  3     1 Origin1
4  4     1 Origin1
5  5     1 Origin1
6  6     1 Origin1
> origin_pred2 <- ore.pull(origin_pred) # Retrieve the origin_pred result # scored from DB to an R object

Warning message:
ORE object has no unique key - using random order
> origin_pred2$id <- seq_len(nrow(origin_pred2)) # Create a unique index for # the rows in origin_pred2 and assign it to a new column 'id'

> head(origin_pred2) # Display 6 rows of the origin_pred2 data for ids 1 to 6

  Origin1 Origin2 Origin3 prediction  origin id
1   1.000   0.000   0.000    Origin1 Origin1  1
2   0.994   0.004   0.002    Origin1 Origin1  2
3   1.000   0.000   0.000    Origin1 Origin1  3
4   1.000   0.000   0.000    Origin1 Origin1  4
5   1.000   0.000   0.000    Origin1 Origin1  5
6   1.000   0.000   0.000    Origin1 Origin1  6
> row.names(origin_pred2) <- origin_pred2$id  # Assigns the id column for # each row to corresponding value of the sequence created for 
id

> head(test_data) # Display 6 rows of test_data after adding 'origin' and # 'id' columns.

  class Alcohol Malic.acid  Ash Alcanility.of.ash Magnesium Total.phenols
1     1   14.37       1.95 2.50              16.8       113          3.85
2     1   14.20       1.76 2.45              15.2       112          3.27
3     1   14.06       2.15 2.61              17.6       121          2.60
4     1   13.64       3.10 2.56              15.2       116          2.70
5     1   14.06       1.63 2.28              16.0       126          3.00
6     1   12.85       1.60 2.52              17.8        95          2.48
  Flavanoids Nonflavanoid.phenols Proanthocyanins Color.intensity    Hue
1       3.49                 0.24            2.18            7.80   0.86
2       3.39                 0.34            1.97            6.75   1.05
3       2.51                 0.31            1.25            5.05   1.06
4       3.03                 0.17            1.66            5.10   0.96
5       3.17                 0.24            2.10            5.65   1.09
6       2.37                 0.26            1.46            3.93   1.09
  OD280.OD315.of.diluted.wines Proline  origin id

1                         3.45    1480 Origin1  1
2                         2.85    1450 Origin1  2
3                         3.58    1295 Origin1  3
4                         3.36     845 Origin1  4
5                         3.71     780 Origin1  5
6                         3.63    1015 Origin1  6
> head(origin_pred2) # Display 6 rows of origin_pred2 along with id column

  Origin1 Origin2 Origin3 prediction  origin id
1   1.000   0.000   0.000    Origin1 Origin1  1
2   0.994   0.004   0.002    Origin1 Origin1  2
3   1.000   0.000   0.000    Origin1 Origin1  3
4   1.000   0.000   0.000    Origin1 Origin1  4
5   1.000   0.000   0.000    Origin1 Origin1  5
6   1.000   0.000   0.000    Origin1 Origin1  6
> head(origin_pred2[,c(6,5,4)]) # Display 6 rows of origin_pred2 containg # only the 6th, 5th, and 4th columns  id  origin prediction

1  1 Origin1    Origin1
2  2 Origin1    Origin1
3  3 Origin1    Origin1
4  4 Origin1    Origin1
5  5 Origin1    Origin1
6  6 Origin1    Origin1
> df1 <- test_data[,c(16,15,1:14)] # Assign a data frame called df1 for the # subset of test_data with 16th, 15th, and 1 to 14th, columns

> df2 <- origin_pred2[, c(1:6)] # Assign a data frame called df2 for the # subset of origin_pred2 with columns 1st to 6th.

> class(df1)
[1] "data.frame"
> df1_new <- df1[order(df1$origin),] # Sort the df1 data frame on the origin # column and assign the sorted data to the df1_new data frame

> head(df1_new) # Display 6 rows of sorted data in df1_new

  id  origin class Alcohol Malic.acid  Ash Alcanility.of.ash Magnesium

1  1 Origin1     1   14.37       1.95 2.50              16.8       113
2  2 Origin1     1   14.20       1.76 2.45              15.2       112
3  3 Origin1     1   14.06       2.15 2.61              17.6       121
4  4 Origin1     1   13.64       3.10 2.56              15.2       116
5  5 Origin1     1   14.06       1.63 2.28              16.0       126
6  6 Origin1     1   12.85       1.60 2.52              17.8        95
  Total.phenols Flavanoids Nonflavanoid.phenols Proanthocyanins Color.intensity
1          3.85       3.49              0.24            2.18            7.80
2          3.27       3.39              0.34            1.97            6.75
3          2.60       2.51              0.31            1.25            5.05
4          2.70       3.03              0.17            1.66            5.10
5          3.00       3.17              0.24            2.10            5.65
6          2.48       2.37              0.26            1.46            3.93
   Hue OD280.OD315.of.diluted.wines Proline
1 0.86                         3.45    1480
2 1.05                         2.85    1450
3 1.06                         3.58    1295
4 0.96                         3.36     845
5 1.09                         3.71     780
6 1.09                         3.63    1015
> df2_new <- df2[order(df2$origin),] # Sort the df2 data frame on the origin # column and assign the sorted data to the df2_new data 
frame

> head(df2_new) # Display 6 rows of the df2_new sorted data frame

  Origin1 Origin2 Origin3 prediction  origin id
1   1.000   0.000   0.000    Origin1 Origin1  1
2   0.994   0.004   0.002    Origin1 Origin1  2
3   1.000   0.000   0.000    Origin1 Origin1  3
4   1.000   0.000   0.000    Origin1 Origin1  4
5   1.000   0.000   0.000    Origin1 Origin1  5
6   1.000   0.000   0.000    Origin1 Origin1  6
> nrow(df1_new) # Display count of rows in df1_new

[1] 413
> nrow(df2_new) # Display count of rows in df2_new

[1] 413
> data_set <- data.frame(df1_new, df2_new) # Create a combined data frame of # df1_new and df2_new and store it in data_set data frame

> nrow(data_set) # Display count of rows in data_set

[1] 413
> head(data_set) # Display 6 rows of data_set

  id  origin class Alcohol Malic.acid  Ash Alcanility.of.ash Magnesium
1  1 Origin1     1   14.37       1.95 2.50              16.8       113
2  2 Origin1     1   14.20       1.76 2.45              15.2       112
3  3 Origin1     1   14.06       2.15 2.61              17.6       121
4  4 Origin1     1   13.64       3.10 2.56              15.2       116
5  5 Origin1     1   14.06       1.63 2.28              16.0       126
6  6 Origin1     1   12.85       1.60 2.52              17.8        95
  Total.phenols Flavanoids Nonflavanoid.phenols Proanthocyanins Color.intensity

1          3.85       3.49              0.24            2.18            7.80
2          3.27       3.39              0.34            1.97            6.75
3          2.60       2.51              0.31            1.25            5.05
4          2.70       3.03              0.17            1.66            5.10
5          3.00       3.17              0.24            2.10            5.65
6          2.48       2.37              0.26            1.46            3.93
   Hue OD280.OD315.of.diluted.wines Proline Origin1 Origin2 Origin3 prediction
1 0.86                      3.45    1480   1.000   0.000   0.000    Origin1
2 1.05                      2.85    1450   0.994   0.004   0.002    Origin1
3 1.06                      3.58    1295   1.000   0.000   0.000    Origin1
4 0.96                      3.36     845   1.000   0.000   0.000    Origin1
5 1.09                      3.71     780   1.000   0.000   0.000    Origin1
6 1.09                      3.63    1015   1.000   0.000   0.000    Origin1
  origin.1 id.1
1  Origin1    1
2  Origin1    2
3  Origin1    3
4  Origin1    4
5  Origin1    5
6  Origin1    6
> colnames(data_set)[20] <- "Source"  # Assign the label "Source" to the # 20th column in the data_set data frame

> head(data_set)
  id  origin class Alcohol Malic.acid  Ash Alcanility.of.ash Magnesium
1  1 Origin1     1   14.37       1.95 2.50              16.8       113
2  2 Origin1     1   14.20       1.76 2.45              15.2       112
3  3 Origin1     1   14.06       2.15 2.61              17.6       121
4  4 Origin1     1   13.64       3.10 2.56              15.2       116
5  5 Origin1     1   14.06       1.63 2.28              16.0       126
6  6 Origin1     1   12.85       1.60 2.52              17.8        95
  Total.phenols Flavanoids Nonflavanoid.phenols Proanthocyanins Color.intensity

1          3.85       3.49              0.24            2.18            7.80
2          3.27       3.39              0.34            1.97            6.75
3          2.60       2.51              0.31            1.25            5.05
4          2.70       3.03              0.17            1.66            5.10
5          3.00       3.17              0.24            2.10            5.65
6          2.48       2.37              0.26            1.46            3.93
   Hue OD280.OD315.of.diluted.wines Proline Origin1 Origin2 Origin3  Source
1 0.86                         3.45    1480   1.000   0.000   0.000 Origin1
2 1.05                         2.85    1450   0.994   0.004   0.002 Origin1
3 1.06                         3.58    1295   1.000   0.000   0.000 Origin1
4 0.96                         3.36     845   1.000   0.000   0.000 Origin1
5 1.09                         3.71     780   1.000   0.000   0.000 Origin1
6 1.09                         3.63    1015   1.000   0.000   0.000 Origin1
  origin.1 id.1
1  Origin1    1
2  Origin1    2
3  Origin1    3
4  Origin1    4
5  Origin1    5
6  Origin1    6
> data_set$propensity_to_buy <- ifelse((data_set$Source == 'Origin1'), 1,# create a new column propensity_to_buy based on 'Source' 
column

+ ifelse((data_set$Source == 'Origin2'), 0,
+ ifelse((data_set$Source == 'Origin3'), 1, '')))
> class(data_set) # Display class of final data_set

[1] "data.frame"
> nrow(data_set) # Display count of rows in final data_set

[1] 413
> head(data_set) # Display 6 rows in final data_set

  id  origin class Alcohol Malic.acid  Ash Alcanility.of.ash Magnesium
1  1 Origin1     1   14.37       1.95 2.50              16.8       113
2  2 Origin1     1   14.20       1.76 2.45              15.2       112
3  3 Origin1     1   14.06       2.15 2.61              17.6       121
4  4 Origin1     1   13.64       3.10 2.56              15.2       116
5  5 Origin1     1   14.06       1.63 2.28              16.0       126
6  6 Origin1     1   12.85       1.60 2.52              17.8        95
  Total.phenols Flavanoids Nonflavanoid.phenols Proanthocyanins Color.intensity
1          3.85       3.49              0.24            2.18            7.80
2          3.27       3.39              0.34            1.97            6.75
3          2.60       2.51              0.31            1.25            5.05
4          2.70       3.03              0.17            1.66            5.10
5          3.00       3.17              0.24            2.10            5.65
6          2.48       2.37              0.26            1.46            3.93
   Hue OD280.OD315.of.diluted.wines Proline Origin1 Origin2 Origin3  Source

1 0.86                         3.45    1480   1.000   0.000   0.000 Origin1
2 1.05                         2.85    1450   0.994   0.004   0.002 Origin1
3 1.06                         3.58    1295   1.000   0.000   0.000 Origin1
4 0.96                         3.36     845   1.000   0.000   0.000 Origin1
5 1.09                         3.71     780   1.000   0.000   0.000 Origin1
6 1.09                         3.63    1015   1.000   0.000   0.000 Origin1
  origin.1 id.1 propensity_to_buy
1  Origin1    1                 1
2  Origin1    2                 1
3  Origin1    3                 1
4  Origin1    4                 1
5  Origin1    5                 1
6  Origin1    6                 1
> write.csv(data_set, "Wineptobuy.csv", row.names=FALSE) # Write the data # contained in data_set to a new .csv file in working directory

> 

```

### 解决方案的第二部分

既然我们已经预测了葡萄酒的产地，并且用列`Source`创建了一个新的数据集，我们需要用它来预测购买倾向。如本节开头所述，我们将使用逻辑回归机器学习算法，通过应用广义线性模型来拟合数据。使用的预测变量是`Source`，响应变量是`propensity_to_buy`。清单 [6-2](#Par15) 显示了代码。

```
library(ORE)
ore.connect("testr","orcl","localhost","testr")
library(OREmodels)
winedata <- read.csv("Wineptobuy.csv", header=TRUE, row.names = NULL, sep=',')
head(winedata)
summary(winedata)
sapply(winedata, sd)
xtabs(∼propensity_to_buy +Source, data=winedata)
xtabs(∼propensity_to_buy +origin, data=winedata)
label <- winedata[,23]
head(label)
library(caTools)
s <- sample.split(label, SplitRatio=3/4)
train_set <- winedata[s, c(2:20, 23)]
test_set <- winedata[!s, c(2:20, 23)]
head(train_set)
nrow(train_set)
head(test_set)
nrow(test_set)
sp.tab <- table(train_set$Source, train_set$propensity_to_buy)
sp.tab
train_set$Source <- factor(train_set$Source)
logitM <- glm(propensity_to_buy ∼ Source, data = train_set, family="binomial", control = glm.control(maxit=100))
summary(logitM)
anova(logitM)
# install.packages("aod")
library(aod)
wald.test(b = coef(logitM), Sigma = vcov(logitM), Terms =  1:2)
wald.test(b = coef(logitM), Sigma = vcov(logitM), Terms =  1:3)
wald.test(b = coef(logitM), Sigma = vcov(logitM), Terms =  2:3)
exp(coef(logitM))
head(test_set)
nrow(test_set)
head(data.frame(test_set[,c(1:19)]))
nrow(data.frame(test_set[,c(1:19)]))
test_set$p_to_buyPred <- predict(logitM,  newdata = data.frame(test_set[,c(1:19)]), type="response")
class(test_set$p_to_buyPred)
head(test_set)
test_set$p_to_buyPred <- ifelse(test_set$p_to_buyPred > 0.5,1,0)
misClasificError <- mean(test_set$p_to_buyPred != test_set$propensity_to_buy)
print(paste('Accuracy',1-misClasificError))
####
library(ROCR)
class(test_set$p_to_buyPred)
pr1 <- prediction(test_set$p_to_buyPred, test_set$propensity_to_buy)
class(pr1)
prf1 <- performance(pr1, measure = "tpr", x.measure = "fpr")
class(prf1)
pdf("plot_prf1.pdf")
plot(prf1, colorize = TRUE) # , text.adj = c(-0.2,1.7)
dev.off()
auc1 <- performance(pr1, measure = "auc")
auc1 <- auc1@y.values[[1]]
auc1
####

library(ROCR)
p <- predict(logitM, newdata= data.frame(test_set[,c(1:19)]), type="response")
class(p)
pr <- prediction(p, test_set$propensity_to_buy)
class(pr)
prf <- performance(pr, measure = "tpr", x.measure = "fpr")
class(prf)
plot(prf, colorize = TRUE) # , text.adj = c(-0.2,1.7)
auc <- performance(pr, measure = "auc")
auc <- auc@y.values[[1]]
auc
test_set2 <- data.frame(test_set[,c(1:19)])
test_set3 <- cbind(test_set2, predict(logitM, newdata=test_set2, type = "link", se = TRUE))
test_set3 <- within(test_set3, {
PredictedProb <- plogis(fit)
LL <- plogis(fit - (1.96 * se.fit))
UL <- plogis(fit + (1.96 * se.fit))
})
head(test_set3)

Listing 6-2.Using Logistic Regression to Determine the Propensity to Buy Based on the Wine Source

```

下一部分显示了`ggplot2`功能。在第 [5](5.html) 章“图形输出分析:根据葡萄酒来源预测购买倾向”一节中给出了对`ggplot`的描述

```
library(ggplot2)
pdf("test_set3_ribbon.pdf")
ggplot(test_set3, aes(x = Source, y = PredictedProb, group=PredictedProb)) +
geom_line(aes(colour = PredictedProb), size = 1) + geom_point() +
geom_ribbon(aes(ymin = LL, ymax = UL, fill = PredictedProb), alpha = 0.25)  +
scale_fill_gradient(low="red", high="green") +
ggtitle("Predicting Propensity to buy based on Wine Source") +
ylab("Predicted Probability - p_to_buyPred")
dev.off()
fillc_train <- train_set$Source # c("Origin1", "Origin2", "Origin3")
train_set <- cbind(train_set, fillc_train)
library(ggplot2)
pdf("WineOriginTrainingDataGLMPlot_test_bar.pdf")
ggplot(data=train_set, aes(x=Source, y=propensity_to_buy, fill = Source)) +
geom_bar(stat="identity", width=0.25) +
scale_fill_manual("legend", values = c("Origin1" = "green", "Origin2" = "orange", "Origin3" = "blue"))
dev.off()
fillc_test <- test_set$Source
test_set <- cbind(test_set, fillc_test)
library(ggplot2)
pdf("WineOriginTestDataGLMPlot_test_bar.pdf")
ggplot(data=test_set, aes(x=Source, y=p_to_buyPred, fill = Source)) +
geom_bar(stat="identity", width=0.25)  +
scale_fill_manual("legend", values = c("Origin1" = "green", "Origin2" = "orange", "Origin3" = "blue"))
dev.off()
library(ggplot2)
pdf("WineOriginTrainingDataGLMPlot_test_lineNpoint.pdf")
ggplot(data=train_set, aes(x=Source, y=propensity_to_buy, group=1)) +
geom_line(aes(colour = propensity_to_buy), size = 1) + geom_point() +
stat_smooth(method="glm", family="binomial", se=FALSE)
dev.off()
library(ggplot2)
pdf("WineOriginTestDataGLMPlot_test_lineNpoint.pdf")
ggplot(data=test_set, aes(x=Source, y=p_to_buyPred, group=1)) +
geom_line(aes(colour = p_to_buyPred), size = 1) + geom_point() +
stat_smooth(method="glm", family="binomial", se=FALSE)
dev.off()

```

下面是执行清单 [6-2](#Par15) 中代码的输出:

```
> library(ORE) # load the ORE library which is the primary library for # Oracle R Enterprise execution
Loading required package: OREbase
Loading required package: OREcommon

Attaching package: 'OREbase'

The following objects are masked from 'package:base':

    cbind, data.frame, eval, interaction, order, paste, pmax, pmin,
    rbind, table

Loading required package: OREembed
Loading required package: OREstats
Loading required package: MASS
Loading required package: OREgraphics
Loading required package: OREeda
Loading required package: OREmodels
Loading required package: OREdm
Loading required package: lattice
Loading required package: OREpredict
Loading required package: ORExml
> ore.connect("testr","orcl","localhost","testr") # Using ORE requires # connecting to the Oracle DB
> library(OREmodels) # load the OREmodels library for calling ORE machine # learning model(s)
# The file Wineptobuy.csv is as

sumed to be in the working directory from # where the ORE CLI is called
> winedata <- read.csv("Wineptobuy.csv", header=TRUE, row.names =$ # Loads # input data in .csv file into an R data frame called winedata
> head(winedata) # Displays 6 rows of data in the data frame winedata
  id  origin class Alcohol Malic.acid  Ash Alcanility.of.ash Magnesium
1  1 Origin1     1   14.37       1.95 2.50              16.8       113
2  2 Origin1     1   14.20       1.76 2.45              15.2       112
3  3 Origin1     1   14.06       2.15 2.61              17.6       121
4  4 Origin1     1   13.64       3.10 2.56              15.2       116
5  5 Origin1     1   14.06       1.63 2.28              16.0       126
6  6 Origin1     1   12.85       1.60 2.52              17.8        95
  Total.phenols Flavanoids Nonflavanoid.phenols Proanthocyanins Color.intensity

1          3.85       3.49              0.24            2.18            7.80
2          3.27       3.39              0.34            1.97            6.75
3          2.60       2.51              0.31            1.25            5.05
4          2.70       3.03              0.17            1.66            5.10
5          3.00       3.17              0.24            2.10            5.65
6          2.48       2.37              0.26            1.46            3.93
   Hue OD280.OD315.of.diluted.wines Proline Origin1 Origin2 Origin3  Source
1 0.86                         3.45    1480   1.000   0.000   0.000 Origin1
2 1.05                         2.85    1450   0.994   0.004   0.002 Origin1
3 1.06                         3.58    1295   1.000   0.000   0.000 Origin1
4 0.96                         3.36     845   1.000   0.000   0.000 Origin1
5 1.09                         3.71     780   1.000   0.000   0.000 Origin1
6 1.09                         3.63    1015   1.000   0.000   0.000 Origin1
  origin.1 id.1 propensity_to_buy

1  Origin1    1                 1
2  Origin1    2                 1
3  Origin1    3                 1
4  Origin1    4                 1
5  Origin1    5                 1
6  Origin1    6                 1
> summary(winedata) # Gives a statistical summary of the data in winedata # data frame as shown below for each variable/attribute

       id          origin        class         Alcohol        Malic.acid
 Min.   :  1   Origin1:140   Min.   :1.00   Min.   :11.03   Min.   :0.740
 1st Qu.:104   Origin2:162   1st Qu.:1.00   1st Qu.:12.37   1st Qu.:1.530
 Median :207   Origin3:111   Median :2.00   Median :13.05   Median :1.830
 Mean   :207                 Mean   :1.93   Mean   :13.00   Mean   :2.343
 3rd Qu.:310                 3rd Qu.:3.00   3rd Qu.:13.67   3rd Qu.:3.100
 Max.   :413                 Max.   :3.00   Max.   :14.75   Max.   :5.800
      Ash        Alcanility.of.ash   Magnesium      Total.phenols
 Min.   :1.360   Min.   :10.60     Min.   : 70.00   Min.   :0.980
 1st Qu.:2.210   1st Qu.:17.00     1st Qu.: 89.00   1st Qu.:1.740
 Median :2.360   Median :19.00     Median : 97.00   Median :2.230
 Mean   :2.366   Mean   :19.43     Mean   : 99.58   Mean   :2.276
 3rd Qu.:2.580   3rd Qu.:21.50     3rd Qu.:107.00   3rd Qu.:2.800
 Max.   :3.230   Max.   :30.00     Max.   :162.00   Max.   :3.880
   Flavanoids    Nonflavanoid.phenols Proanthocyanins Color.intensity
 Min.   :0.340   Min.   :0.1300       Min.   :0.410   Min.   : 1.280
 1st Qu.:1.200   1st Qu.:0.2700       1st Qu.:1.140   1st Qu.: 3.300
 Median :2.140   Median :0.3400       Median :1.460   Median : 4.600
 Mean   :2.011   Mean   :0.3658       Mean   :1.538   Mean   : 4.934
 3rd Qu.:2.780   3rd Qu.:0.4500       3rd Qu.:1.870   3rd Qu.: 5.850
 Max.   :5.080   Max.   :0.6600       Max.   :3.580   Max.   :13.000
      Hue         OD280.OD315.of.diluted.wines    Proline

 Min.   :0.5400   Min.   :1.270                Min.   : 278.0
 1st Qu.:0.7600   1st Qu.:1.830                1st Qu.: 510.0
 Median :0.9600   Median :2.780                Median : 678.0
 Mean   :0.9618   Mean   :2.587                Mean   : 749.5
 3rd Qu.:1.1300   3rd Qu.:3.140                3rd Qu.: 985.0
 Max.   :1.7100   Max.   :4.000                Max.   :1680.0
    Origin1          Origin2        Origin3           Source       origin.1
 Min.   :0.0000   Min.   :0.0000  Min.   :0.0000   Origin1:140   Origin1:140
 1st Qu.:0.0000   1st Qu.:0.0000   1st Qu.:0.0000   Origin2:162   Origin2:162
 Median :0.0000   Median :0.0020  Median :0.0000   Origin3:111   Origin3:111
 Mean   :0.3395   Mean   :0.3922   Mean   :0.2683
 3rd Qu.:1.0000   3rd Qu.:1.0000   3rd Qu.:0.9760
 Max.   :1.0000   Max.   :1.0000   Max.   :1.0000
      id.1     propensity_to_buy
 Min.   :  1   Min.   :0.0000
 1st Qu.:104   1st Qu.:0.0000
 Median :207   Median :1.0000
 Mean   :207   Mean   :0.6077
 3rd Qu.:310   3rd Qu.:1.0000
 Max.   :413   Max.   :1.0000
> sapply(winedata, sd) # Applies the standard deviation sd function to each # variable in the data set winedata

                          id                       origin
                 119.3670809                    0.7773550
                       class                      Alcohol
                   0.7773550                    0.7667311
                  Malic.acid                          Ash
                   1.1720914                    0.2931987
           Alcanility.of.ash                    Magnesium
                   3.4096871                   14.2594176
               Total.phenols                   Flavanoids
                   0.6270436                    0.9700433
        Nonflavanoid.phenols              Proanthocyanins
                   0.1293551                    0.5520653
             Color.intensity                          Hue
                   2.1460253                    0.2289449
OD280.OD315.of.diluted.wines                      Proline
                   0.7162199                  311.4138632
                     Origin1                      Origin2
                   0.4731436                    0.4869368
                     Origin3                       Source
                   0.4421105                    0.7773550
                    origin.1                         id.1
                   0.7773550                  119.3670809
           propensity_to_buy

                   0.4888445

```

下面两行分别显示了响应变量`propensity_to_buy`和预测变量`Source`和`origin`的双向列联表，以确保`winedata`数据集中没有 0 单元格。换句话说，`xtabs`函数将分类变量级别的频率或计数显示为一个矩阵或表格——一个交叉列表，揭示了`propensity_to_buy`和`Source` `,`以及`propensity_to_buy`和`origin`之间的关系。

```
> xtabs(∼propensity_to_buy +Source, data=winedata)
                 Source
propensity_to_buy Origin1 Origin2 Origin3
                0       0     162       0
                1     140       0     111
> xtabs(∼propensity_to_buy +origin, data=winedata)
                 origin
propensity_to_buy Origin1 Origin2 Origin3
                0       0     162       0
                1     140       0     111
> label <- winedata[,23]
> head(label)
[1] 1 1 1 1 1 1
> library(caTools)
Warning message:
package 'caTools' was built under R version 3.2.5
> s <- sample.split(label, SplitRatio=3/4) # Derives a sample split s based # on split ratio of 0.75
> train_set <- winedata[s, c(2:20, 23)] # Samples the input data into train_# set (columns 2-20, and 23) based on s
> test_set <- winedata[!s, c(2:20, 23)] # Samples the data not in train_set # into test_set
> head(train_set) # Displays 6 rows in the train_set
   origin class Alcohol Malic.acid  Ash Alcanility.of.ash Magnesium

1 Origin1     1   14.37       1.95 2.50              16.8       113
3 Origin1     1   14.06       2.15 2.61              17.6       121
4 Origin1     1   13.64       3.10 2.56              15.2       116
5 Origin1     1   14.06       1.63 2.28              16.0       126
6 Origin1     1   12.85       1.60 2.52              17.8        95
7 Origin1     1   13.87       1.90 2.80              19.4       107
  Total.phenols Flavanoids Nonflavanoid.phenols Proanthocyanins Color.intensity
1          3.85       3.49              0.24            2.18            7.80
3          2.60       2.51              0.31            1.25            5.05
4          2.70       3.03              0.17            1.66            5.10
5          3.00       3.17              0.24            2.10            5.65
6          2.48       2.37              0.26            1.46            3.93
7          2.95       2.97              0.37            1.76            4.50
   Hue OD280.OD315.of.diluted.wines Proline Origin1 Origin2 Origin3  Source
1 0.86                         3.45    1480   1.000   0.000       0 Origin1
3 1.06                         3.58    1295   1.000   0.000       0 Origin1
4 0.96                         3.36     845   1.000   0.000       0 Origin1
5 1.09                         3.71     780   1.000   0.000       0 Origin1
6 1.09                         3.63    1015   1.000   0.000       0 Origin1
7 1.25                         3.40     915   0.996   0.004       0 Origin1
  propensity_to_buy
1                 1
3                 1
4                 1
5                 1
6                 1
7                 1
> nrow(train_set) # Displays count of rows in train set

[1] 310
> head(test_set) # Displays 6 rows in the test_set
    origin class Alcohol Malic.acid  Ash Alcanility.of.ash Magnesium
2  Origin1     1   14.20       1.76 2.45              15.2       112
9  Origin1     1   13.51       1.80 2.65              19.0       110
10 Origin1     1   13.05       1.65 2.55              18.0        98
11 Origin1     1   13.88       1.89 2.59              15.0       101
13 Origin1     1   14.38       3.59 2.28              16.0       102
17 Origin1     1   13.83       1.65 2.60              17.2        94
   Total.phenols Flavanoids Nonflavanoid.phenols Proanthocyanins
2           3.27       3.39                 0.34            1.97
9           2.35       2.53                 0.29            1.54
10          2.45       2.43                 0.29            1.44
11          3.25       3.56                 0.17            1.70
13          3.25       3.17                 0.27            2.19
17          2.45       2.99                 0.22            2.29
   Color.intensity  Hue OD280.OD315.of.diluted.wines Proline Origin1 Origin2
2             6.75 1.05                         2.85    1450   0.994   0.004
9             4.20 1.10                         2.87    1095   1.000   0.000
10            4.25 1.12                         2.51    1105   1.000   0.000
11            5.43 0.88                         3.56    1095   0.996   0.002
13            4.90 1.04                         3.44    1065   1.000   0.000
17            5.60 1.24                         3.37    1265   1.000   0.000
   Origin3  Source propensity_to_buy
2    0.002 Origin1                 1
9    0.000 Origin1                 1
10   0.000 Origin1                 1
11   0.002 Origin1                 1
13   0.000 Origin1                 1
17   0.000 Origin1                 1

> nrow(test_set) # Displays count of rows in test set
[1] 103
# Loads a matrix of Source and propensity_to_buy columns in train_set into # sp.tab
> sp.tab <- table(train_set$Source, train_set$propensity_to_buy)
> sp.tab # Display the above matrix

            0   1
  Origin1   0 104
  Origin2 122   0
  Origin3   0  84
> train_set$Source <- factor(train_set$Source) # This treats source as a # categorical variable

```

我们通过使用`glm`机器学习算法在 R 中建立逻辑回归模型，其中响应变量为`propensity_to_buy`，预测变量为使用`train_set`数据集的`Source,`。glm 模型的族函数`is "binomial"`(表示模型是二项式模型)，链接是`logit`，要执行的最大迭代是 100:

```
> logitM <- glm(propensity_to_buy ∼ Source, data = train_set, family="binomial$

```

我们显示了根据对`glm:`偏差残差(最小值、第一个分位数、中值、第三个分位数和最大值)的函数调用刚刚构建的`logitM`模型的摘要，偏差残差是模型拟合的度量，或者换句话说，是模型中使用的观测值的偏差残差的分布；系数表，其中系数、其标准误差、Z 统计量或 Wald Z 统计量以及相关的 p 值显示在矩阵中，截距和预测变量显示在矩阵下方；拟合指数，包括零偏差和剩余偏差以及阿凯克信息标准(AIC)。具有最小 AIC 值的模型被认为是适合的，而不会对模型系数造成损失。

```
> summary(logitM)

Call:
glm(formula = propensity_to_buy ∼ Source, family = "binomial",
    data = train_set, control = glm.control(maxit = 100))

Deviance Residuals:
       Min          1Q      Median          3Q         Max
-8.861e-07  -8.861e-07   8.861e-07   8.861e-07   8.861e-07

Coefficients:
                Estimate Std. Error z value Pr(>|z|)
(Intercept)    2.857e+01  9.493e+04       0        1
SourceOrigin2 -5.713e+01  1.292e+05       0        1
SourceOrigin3 -1.927e-05  1.420e+05       0        1

(Dispersion parameter for binomial family taken to be 1)

    Null deviance: 4.1559e+02  on 309  degrees of freedom

Residual deviance: 2.4340e-10  on 307  degrees of freedom

AIC: 6

Number of Fisher Scoring iterations: 27

> anova(logitM)
Analysis of Deviance Table

Model: binomial, link: logit

Response: propensity_to_buy

Terms added sequentially (first to last)

       Df Deviance Resid. Df Resid. Dev
NULL                     309     415.59
Source  2   415.59       307       0.00
> # install.packages("aod")

```

`wald.test`函数根据`logitM`模型的系数测试卡方检验统计量。在我们的例子中，我们可以通过使用 r 的`aod`库中的函数来测试`Source`预测变量的显著性。系数表中模型系数的顺序与模型中项的顺序相同。这是相关的，因为`wald.test`函数通过其在模型中的顺序引用其系数。在接下来的三个`wald.test`调用中，参数`b`传递系数，`Sigma`给出误差项的方差和协方差矩阵，`Terms`指示模型中的哪些项要被测试。在我们的用例中，这是术语 2 和 3。此外，对第 1 项和第 2 项以及第 2 项和第 3 项之外的第 1 项、第 2 项和第 3 项运行函数`wald.test`，分别得出自由度为 2、3 和 2 的卡方检验统计量，以及所有三种情况下的 p 值 1.0，从而表明`Source`在统计上具有显著性。

```
> library(aod)
Warning message:
package 'aod' was built under R version 3.2.5
> wald.test(b = coef(logitM), Sigma = vcov(logitM), Terms =  1:2)
Wald test:
----------

Chi-squared test:
X2 = 2e-07, df = 2, P(> X2) = 1.0
> wald.test(b = coef(logitM), Sigma = vcov(logitM), Terms =  1:3)
Wald test:
----------

Chi-squared test:
X2 = 2.7e-07, df = 3, P(> X2) = 1.0
> wald.test(b = coef(logitM), Sigma = vcov(logitM), Terms =  2:3)
Wald test:
----------

Chi-squared test:
X2 = 2.6e-07, df = 2, P(> X2) = 1.0
> exp(coef(logitM)) # The exp function exponentiates the coefficients and # analyzes them as odds-ratios.
  (Intercept) SourceOrigin2 SourceOrigin3
 2.547392e+12  1.541056e-25  9.999807e-01
> head(test_set) # Displays 6 rows of the test_set data set
    origin class Alcohol Malic.acid  Ash Alcanility.of.ash Magnesium
2  Origin1     1   14.20       1.76 2.45              15.2       112
9  Origin1     1   13.51       1.80 2.65              19.0       110
10 Origin1     1   13.05       1.65 2.55              18.0        98
11 Origin1     1   13.88       1.89 2.59              15.0       101
13 Origin1     1   14.38       3.59 2.28              16.0       102
17 Origin1     1   13.83       1.65 2.60              17.2        94
   Total.phenols Flavanoids Nonflavanoid.phenols Proanthocyanins
2           3.27       3.39                 0.34            1.97
9           2.35       2.53                 0.29            1.54
10          2.45       2.43                 0.29            1.44
11          3.25       3.56                 0.17            1.70
13          3.25       3.17                 0.27            2.19
17          2.45       2.99                 0.22            2.29
   Color.intensity  Hue OD280.OD315.of.diluted.wines Proline Origin1 Origin2
2             6.75 1.05                         2.85    1450   0.994   0.004
9             4.20 1.10                         2.87    1095   1.000   0.000
10            4.25 1.12                         2.51    1105   1.000   0.000
11            5.43 0.88                         3.56    1095   0.996   0.002
13            4.90 1.04                         3.44    1065   1.000   0.000
17            5.60 1.24                         3.37    1265   1.000   0.000
   Origin3  Source propensity_to_buy
2    0.002 Origin1                 1
9    0.000 Origin1                 1
10   0.000 Origin1                 1
11   0.002 Origin1                 1
13   0.000 Origin1                 1
17   0.000 Origin1                 1
> nrow(test_set) # Displays number of rows in test_set
[1] 103
> head(data.frame(test_set[,c(1:19)])) # Displays 6 rows of columns 1 to 19 # in test_set
   origin class Alcohol Malic.acid  Ash Alcanility.of.ash Magnesium
1 Origin1     1   14.20       1.76 2.45              15.2       112
2 Origin1     1   13.51       1.80 2.65              19.0       110
3 Origin1     1   13.05       1.65 2.55              18.0        98
4 Origin1     1   13.88       1.89 2.59              15.0       101
5 Origin1     1   14.38       3.59 2.28              16.0       102
6 Origin1     1   13.83       1.65 2.60              17.2        94
  Total.phenols Flavanoids Nonflavanoid.phenols Proanthocyanins Color.intensity
1         3.27       3.39              0.34            1.97            6.75
2         2.35       2.53              0.29            1.54            4.20
3         2.45       2.43              0.29            1.44            4.25
4         3.25       3.56              0.17            1.70            5.43
5         3.25       3.17              0.27            2.19            4.90
6         2.45       2.99              0.22            2.29            5.60
   Hue OD280.OD315.of.diluted.wines Proline Origin1 Origin2 Origin3  Source
1 1.05                         2.85    1450   0.994   0.004   0.002 Origin1
2 1.10                         2.87    1095   1.000   0.000   0.000 Origin1
3 1.12                         2.51    1105   1.000   0.000   0.000 Origin1
4 0.88                         3.56    1095   0.996   0.002   0.002 Origin1
5 1.04                         3.44    1065   1.000   0.000   0.000 Origin1
6 1.24                         3.37    1265   1.000   0.000   0.000 Origin1
> nrow(data.frame(test_set[,c(1:19)])) # Displays count of rows taking # columns 1 to 19 in test_set
[1] 103

```

我们使用 R 中的`predict()`函数来预测新数据集的购买倾向，该数据集由`test_set`中的所有行和第 1 至 19 列组成，表明预测变量的值来自这个`test_set`，并且`test_set$p_to_buyPred`的值必须是使用`predict()`的预测值。`This is called` `scoring the model` `.`响应类型为`response`，表示预测类型为预测概率，而非实际值。请注意，在对模型评分时，新数据集(`test_set`)中删除了原始列`propensity_to_buy`。它输出一组落在封闭区间`[0,1]`内的概率(与实际值相反)。这些概率存储在`test_set`中新创建的列`p_to_buyPred`中。

```
> test_set$p_to_buyPred <- predict(logitM,  newdata = data.frame(test_set[,c(1$
> class(test_set$p_to_buyPred) # Shows the R class of test_set$p_to_buyPred
[1] "numeric"
> head(test_set) # Displays 6 rows of test_set which includes the newly # created column p_to_buyPred
    origin class Alcohol Malic.acid  Ash Alcanility.of.ash Magnesium
2  Origin1     1   14.20       1.76 2.45              15.2       112
9  Origin1     1   13.51       1.80 2.65              19.0       110
10 Origin1     1   13.05       1.65 2.55              18.0        98
11 Origin1     1   13.88       1.89 2.59              15.0       101
13 Origin1     1   14.38       3.59 2.28              16.0       102
17 Origin1     1   13.83       1.65 2.60              17.2        94
   Total.phenols Flavanoids Nonflavanoid.phenols Proanthocyanins
2           3.27       3.39                 0.34            1.97
9           2.35       2.53                 0.29            1.54
10          2.45       2.43                 0.29            1.44
11          3.25       3.56                 0.17            1.70
13          3.25       3.17                 0.27            2.19
17          2.45       2.99                 0.22            2.29
   Color.intensity  Hue OD280.OD315.of.diluted.wines Proline Origin1 Origin2
2             6.75 1.05                         2.85    1450   0.994   0.004
9             4.20 1.10                         2.87    1095   1.000   0.000
10            4.25 1.12                         2.51    1105   1.000   0.000
11            5.43 0.88                         3.56    1095   0.996   0.002
13            4.90 1.04                         3.44    1065   1.000   0.000
17            5.60 1.24                         3.37    1265   1.000   0.000
   Origin3  Source propensity_to_buy p_to_buyPred
2    0.002 Origin1                 1            1
9    0.000 Origin1                 1            1
10   0.000 Origin1                 1            1
11   0.002 Origin1                 1            1
13   0.000 Origin1                 1            1
17   0.000 Origin1                 1            1
> test_set$p_to_buyPred <- ifelse(test_set$p_to_buyPred > 0.5,1,0) # Quantifies probabilities into values 1 and 0
> misClasificError <- mean(test_set$p_to_buyPred != test_set$propensity_to_buy) # Displays misclassification error
> print(paste('Accuracy',1-misClasificError)) # Displays the accuracy of the # model built and scored.
[1] "Accuracy 1"
> ####

```

接近 1 的精度被认为是最佳的。ROCR 库用于加载绘制接收机工作特性(ROC)的 R 函数。ROC 通过评估真`+ve`率(或灵敏度)和假`-ve`率(或 1-特异性)之间的交叉相关性来总结模型的性能。保持 p > 0.5，ROC 总结了 p > 0.5 的所有可能值的预测。曲线下面积(AUC)是 ROC 的最佳性能指标；AUC 值越高，`glm`模型的预测越好。该软件包通过使用`prediction, performance, and plot` `functions.`使评分分类器的性能可视化，其定义可在 [`http://rocr.bioinf.mpi-sb.mpg.de/`](http://rocr.bioinf.mpi-sb.mpg.de/) 找到。

```
> library(ROCR)
Loading required package: gplots

Attaching package: 'gplots'

The following object is masked from 'package:stats':

    lowess

Warning messages:
1: package 'ROCR' was built under R version 3.2.5
2: package 'gplots' was built under R version 3.2.5
> class(test_set$p_to_buyPred) # Displays the R class of the predicted value # p_to_buyPred of test_set
[1] "numeric"

```

我们使用 GLM 的 R `prediction()`函数将包含预测的输入数据转换成标准格式。这里，它将由`p_to_buyPred`(预测)和`propensity_to_buy`给出的两列数据转换成标准格式，并返回一个类`prediction`的对象。

```
> pr1 <- prediction(test_set$p_to_buyPred, test_set$propensity_to_buy)
> class(pr1) # This gives "prediction" as the class
[1] "prediction"
attr(,"package")
[1] "ROCR"

```

`performance`函数用于进行预测值评估。它的签名是`performance(prediction.obj, measure, x.measure)`。它作用于一个预测对象(在这种情况下为`pr1`)，`measure`是用于评估的性能度量(在这种情况下为`"tpr",`或真阳性率)，而`x.measure`是第二个性能度量(`"fpr",`或假阳性率)。`measure`绘制在 y 轴上，而`x.measure`绘制在 x 轴上，从而得到 2D 曲线。其他指标也可以通过，比如`"auc"`(ROC 下面积)`"acc"`(准确率)`"err"`(错误率)。

```
> prf1 <- performance(pr1, measure = "tpr", x.measure = "fpr")
> class(prf1) # This gives "performance" as the class
[1] "performance"
attr(,"package")
[1] "ROCR"
> pdf("plot_prf1.pdf") # This saves the plotted graph as a PDF file in the # working directory

```

下面绘制了一个类 performance 的对象，在我们的例子中，`prf1\. colorize`指定曲线是否根据截止点着色。

```
> plot(prf1, colorize = TRUE) # , text.adj = c(-0.2,1.7)
> dev.off()
null device
          1

```

这将对`performance()`函数进行不同的调用，将测量值评估为`"auc",`或 ROC 曲线下的面积。这将返回以`"auc"`作为评估标准的先前预测的性能，即 ROC 曲线下的面积。

```
> auc1 <- performance(pr1, measure = "auc")
> auc1 <- auc1@y.values[[1]]
> auc1 # "auc" closer to 1 or equaling 1 indicates a goodness of fit and a # better prediction performance of the model
[1] 1
> ####
> library(ROCR)
> p <- predict(logitM, newdata= data.frame(test_set[,c(1:19)]), type="response$
> class(p)
[1] "numeric"
> pr <- prediction(p, test_set$propensity_to_buy)
> class(pr)
[1] "prediction"
attr(,"package")
[1] "ROCR"
> prf <- performance(pr, measure = "tpr", x.measure = "fpr")
> class(prf)
[1] "performance"
attr(,"package")
[1] "ROCR"
> plot(prf, colorize = TRUE) # , text.adj = c(-0.2,1.7)
> auc <- performance(pr, measure = "auc")
> auc <- auc@y.values[[1]]
> auc
[1] 1
> test_set2 <- data.frame(test_set[,c(1:19)])
> # test_set2$p_to_buyPred <- predict(logitM, newdata=test_set2, type = "link"$

```

`within` R 函数使用`test_set3`数据集作为其参数，并生成一个用于带状层数据的`data.frame`。`within`中的第一行生成预测概率以及标准误差，有助于绘制置信区间。指定参数`se`是为了指示是否显示要使用的置信区间(默认为 0.95)，也使我们能够绘制置信区间。`type="link"`给出了链路规模的估计值。剩余的行将预测值和置信区间反转换成概率。`cbind`将数据帧`test_set2`与作为第二个参数传递给`cbind`的`predict`函数得出的预测结果列进行列绑定。对于逻辑回归模型，置信区间基于剖析的`log-likelihood`函数。`lower`和`upper`分别表示置信下限和置信上限。

```
> test_set3 <- cbind(test_set2, predict(logitM, newdata=test_set2, type = "lin$
> test_set3 <- within(test_set3, {
+ PredictedProb <- plogis(fit)
+ lower <- plogis(fit - (1.96 * se.fit))
+ upper <- plogis(fit + (1.96 * se.fit))
+ })
> head(test_set3)
   origin class Alcohol Malic.acid  Ash Alcanility.of.ash Magnesium
1 Origin1     1   14.20       1.76 2.45              15.2       112
2 Origin1     1   13.51       1.80 2.65              19.0       110
3 Origin1     1   13.05       1.65 2.55              18.0        98
4 Origin1     1   13.88       1.89 2.59              15.0       101
5 Origin1     1   14.38       3.59 2.28              16.0       102
6 Origin1     1   13.83       1.65 2.60              17.2        94
  Total.phenols Flavanoids Nonflavanoid.phenols Proanthocyanins Color.intensity
1          3.27       3.39              0.34            1.97            6.75
2          2.35       2.53              0.29            1.54            4.20
3          2.45       2.43              0.29            1.44            4.25
4          3.25       3.56              0.17            1.70            5.43
5          3.25       3.17              0.27            2.19            4.90
6          2.45       2.99              0.22            2.29            5.60
   Hue OD280.OD315.of.diluted.wines Proline Origin1 Origin2 Origin3  Source
1 1.05                         2.85    1450   0.994   0.004   0.002 Origin1
2 1.10                         2.87    1095   1.000   0.000   0.000 Origin1
3 1.12                         2.51    1105   1.000   0.000   0.000 Origin1
4 0.88                         3.56    1095   0.996   0.002   0.002 Origin1
5 1.04                         3.44    1065   1.000   0.000   0.000 Origin1
6 1.24                         3.37    1265   1.000   0.000   0.000 Origin1
       fit   se.fit residual.scale upper lower PredictedProb
1 28.56609 94925.73              1        1        0             1
2 28.56609 94925.73              1        1        0             1
3 28.56609 94925.73              1        1        0             1
4 28.56609 94925.73              1        1        0             1
5 28.56609 94925.73              1        1        0             1
6 28.56609 94925.73              1        1        0             1
> library(ggplot2)
> pdf("test_set3_ribbon.pdf") # The following line sets up the graph canvas # with response variable on y-axis

> ggplot(test_set3, aes(x = Source, y = PredictedProb, group=PredictedProb)) +
+ geom_line(aes(colour = PredictedProb), size = 1) + geom_point() + # Plots # the actual data points

+ geom_ribbon(aes(ymin = LL, ymax = UL, fill = PredictedProb), alpha = 0.25)  + # alpha fades out connection lines

+ scale_fill_gradient(low="red", high="green") + # Defines a continuous # color scale for the ribbon layer

+ ggtitle("Predicting Propensity to buy based on Wine Source") + # Title of # the final plot

+ ylab("Predicted Probability - p_to_buyPred") # Specify label for y-axis. # This also serves as the graph legend

> dev.off()
windows
      2
>  fillc_train <- train_set$Source # c("Origin1", "Origin2", "Origin3")
>  train_set <- cbind(train_set, fillc_train)
>  library(ggplot2)

```

这将绘制一个条形图，条形图的高度从`train_set data`开始，其中 y 值在`propensity_to_buy`(当`stat="identity"`被指定时)。`scale_fill_manual()`在条形图颜色图例中添加与色调相对的手动刻度。这里，`Origin1`用绿色填充，`Origin2`用橙色填充，`Origin3`用蓝色填充。每个条形的宽度为 0.25 个单位。最终的图表保存在 PDF 文件中。

```
>  pdf("WineOriginTrainingDataGLMPlot_test_bar.pdf")
>  ggplot(data=train_set, aes(x=Source, y=propensity_to_buy, fill = Source)) +
+  geom_bar(stat="identity", width=0.25) +
+  scale_fill_manual("legend", values = c("Origin1" = "green", "Origin2" = "or$
>  dev.off()
null device
          1
>  fillc_test <- test_set$Source
>  test_set <- cbind(test_set, fillc_test)
>  library(ggplot2)
>  pdf("WineOriginTestDataGLMPlot_test_bar.pdf") # This plots a bar graph # with values of p_to_buyPred along the y-axis using data in test_set.
>  ggplot(data=test_set, aes(x=Source, y=p_to_buyPred, fill = Source)) +
+  geom_bar(stat="identity", width=0.25)  +
+  scale_fill_manual("legend", values = c("Origin1" = "green", "Origin2" = "or$
>  dev.off()
null device
          1
> library(ggplot2)
> pdf("WineOriginTrainingDataGLMPlot_test_lineNpoint.pdf")

```

这将使用`train_set`绘制一个连接线图，其中数据点属于`Source`和`propensity_to_buy`所属的同一组。这里，这个组是`#`，指定为`1`。这告诉`ggplot`绘制组 1 中的所有数据点。我们得到一条连接`Origin1`、`Origin2`、`#`和`Origin3`的 V 形线。作为图表的一部分，`geom_line()`的测量刻度或图例出现在线条旁边。`geom_line()`中的颜色参数被指定为`propensity_to_buy`，这意味着它由该变量的级别自动控制。`stat_smooth()`功能在`geom_line`和`geom_point`几何图形上生成并拟合一条平滑线(一条回归线或最佳拟合线),作为一个基于原始数据转换的层，如`glm`模型和`link="binomial"`所做的。这也称为绘制回归斜率。这是作为参数`method="glm"`、`family="binomial"`传递的。指定参数`se`以指示是否显示要使用的置信区间(默认为 0.95)。`method`参数是要使用的平滑方法(在本代码中指定为`glm`，因为我们使用了逻辑回归模型)，而`formula`是平滑函数中要使用的公式。平滑功能有助于识别何时发生过度绘制。

```
> ggplot(data=train_set, aes(x=Source, y=propensity_to_buy, group=1)) +
+ geom_line(aes(colour = propensity_to_buy), size = 1) + geom_point() +
+ stat_smooth(method="glm", family="binomial", se=FALSE)
Warning: Ignoring unknown parameters: family
> dev.off()
null device
          1
> library(ggplot2)
> pdf("WineOriginTestDataGLMPlot_test_lineNpoint.pdf") # This is similar to # the plot above but works on test_set.
> ggplot(data=test_set, aes(x=Source, y=p_to_buyPred, group=1)) +
+ geom_line(aes(colour = p_to_buyPred), size = 1) + geom_point() +
+ stat_smooth(method="glm", family="binomial", se=FALSE)
Warning: Ignoring unknown parameters: family
> dev.off()
null device
          1
>

```

AUC 图和 GLM 图(基于来源与购买倾向)如图 [6-1](#Fig1) 至 [6-6](#Fig6) 所示。

![A439668_1_En_6_Fig6_HTML.jpg](A439668_1_En_6_Fig6_HTML.jpg)

图 6-6。

WineOriginTestDataGLMPlot_test_bar.pdf

![A439668_1_En_6_Fig5_HTML.jpg](A439668_1_En_6_Fig5_HTML.jpg)

图 6-5。

WineOriginTrainingDataGLMPlot_test_bar.pdf

![A439668_1_En_6_Fig4_HTML.jpg](A439668_1_En_6_Fig4_HTML.jpg)

图 6-4。

test_set3_ribbon.pdf (ribbon plot of test_set for predicted probilities)

![A439668_1_En_6_Fig3_HTML.jpg](A439668_1_En_6_Fig3_HTML.jpg)

图 6-3。

WineOriginTestDataGLMPlot_test_lineNpoint.pdf

![A439668_1_En_6_Fig2_HTML.jpg](A439668_1_En_6_Fig2_HTML.jpg)

图 6-2。

WineOriginTrainingDataGLMPlot_test_lineNpoint.pdf

![A439668_1_En_6_Fig1_HTML.jpg](A439668_1_En_6_Fig1_HTML.jpg)

图 6-1。

AUC plot for the execute d GLM model

让我们看看`train_set and test_set:`中来源与购买倾向的矩阵(或表格)

```
> table(train_set$Source, train_set$propensity_to_buy)

            0   1
  Origin1   0  99
  Origin2 122   0
  Origin3   0  89
> table(test_set$Source, test_set$p_to_buyPred)

           0  1
  Origin1  0 34
  Origin2 40  0
  Origin3  0 29
>

```

这些表输出表明两个表中都有一些值为 0 的单元格。这可能导致重要的代码没有显示在`glm`模型的摘要中，如下所示。

`type='response'`简单地将逻辑转换应用于预测的对数优势分数，因此预测是在概率的尺度上。

系数是模型的估计值，其值在对数概率的范围内。

### Logit 模型综述

前面的`summary(logitM)`命令的输出如下:

```
> summary(logitM)

Call:

glm(formula = propensity_to_buy ∼ Source, family = "binomial",

    data = train_set, control = glm.control(maxit = 100))

Deviance Residuals:
       Min          1Q      Median          3Q         Max
-8.861e-07  -8.861e-07   8.861e-07   8.861e-07   8.861e-07

Coefficients:
                Estimate Std. Error z value Pr(>|z|)
(Intercept)    2.857e+01  9.493e+04       0        1
SourceOrigin2 -5.713e+01  1.292e+05       0        1
SourceOrigin3 -1.927e-05  1.420e+05       0        1

(Dispersion parameter for binomial family taken to be 1)

    Null deviance: 4.1559e+02  on 309  degrees of freedom
Residual deviance: 2.4340e-10  on 307  degrees of freedom
AIC: 6

Number of Fisher Scoring iterations: 27

```

该总结给出了关于模型的信息和收敛性。

对我们的 GLM 模型输出的分析可以如下进行:

*   `summary(logitM)`
    *   模型信息和模型收敛状态
        *   打电话
        *   分散参数
        *   费希尔评分迭代次数
    *   系数表
        *   系数
        *   重要代码
    *   测试单个参数
        *   沃尔德卡方统计
    *   单个参数的置信区间
        *   总体拟合优度
            *   null deviation(零偏差)
            *   剩余偏差
            *   赤池信息标准(AIC)
*   `anova(logitM)`
    *   偏差表分析

在这些指标中，AIC、零偏差和剩余偏差以及混淆矩阵和 ROC 曲线给出了`glm`模型的性能。这些概述如下:

如前所述，AIC 代表 Akaike 信息标准，并代表模型中涉及的系数数量的模型成本的拟合度。建议使用 AIC 值较低的型号。在我们的示例用例中，AIC 为 6，如`summary(logitM)`的输出所示，表明该模型非常适合。

零偏差代表只有截距的模型预测的响应。值越低，模型越好。

剩余偏差表示通过使用独立变量的模型进行预测。值越低，模型越好。

混淆矩阵定义了实际值与预测值的表格。这有助于确定模型的准确性，并有助于避免过度拟合。实际值和预测值显示为好值和坏值，像元值由真正值、真负值、假正值和假负值表示。看起来像表 [6-1](#Tab1) 。

表 6-1。

Sample Confusion Matrix in Regard to Logistic Regression

<colgroup><col> <col> <col> <col></colgroup> 
|   |   | 预测 |   |
| --- | --- | --- | --- |
|   |   | 好的 | 严重的 |
| 实际的 | 好的 | True +ve (d) | 假-ve (c) |
|   | 严重的 | False +ve (b) | True -ve (a) |

(Source: [`www.analyticsvidhya.com`](http://www.analyticsvidhya.com) )

关于 ROC 曲线的细节将在后面的小节中介绍。

粗体行给出了关于用作训练数据集的数据集的信息(即`train_set`)、响应和预测变量的标签(分别为`propensity_to_buy`和`Source`)，以及用于拟合的逻辑回归算法的类型(`glm,`或`binary(logit)`族的广义线性模型)。它也给出了参数估计的评分模型类型。

这里，该模型使用 Fisher 评分算法进行最大似然估计。`glm`模型的`maxit`参数给出了拟合模型的迭代次数，这使我们能够确定最大似然估计。

Note

费希尔评分是一个获得结果的上升步骤算法；它通过采取后续步骤(也称为迭代)不断接近最大值(顶部)来最大化可能性。它意识到它已经到达顶部的事实，并且采取后续步骤不会增加可能性。众所周知，这是一个高效的过程——通常不需要很多迭代——并且通常会收敛到一个答案。如果费希尔评分迭代的次数很大，这意味着`glm`模型在收敛性方面不是最优的。如果样本数据集很小或者预测变量之间的相关性不共线，可能会发生这种情况。这是一种数值分析算法，是牛顿-拉夫森方法的替代方法。

在`glm`模型中，二项式链接使用 logit 链接。这表明我们正在拟合一个 logit 模型，响应变量是对数概率，数学上表示如下:

```
logit(p) = l0g(p/(1-p))

```

`logit(p)`取封闭区间`[0,1]`内的值，并输出 y 轴上的实际值。反 logit 函数数据点在 x 轴上，输出闭合区间`[0,1]`中的值在 y 轴上。当涉及的数据是离散的时，如果观察到的响应与其预测值之间存在差异，并且这些值大于`binomial(link=logit)`模型预测的值，则可能出现过度离散。

Note

可以参考`glm`算法背后的数学，详见 [`https://onlinecourses.science.psu.edu/stat504/node/225`](https://onlinecourses.science.psu.edu/stat504/node/225) 。其他网站也解释了逻辑回归模型背后的概念，如[`https://datascienceplus.com/perform-logistic-regression-in-r/`](https://datascienceplus.com/perform-logistic-regression-in-r/)`and`[`www.r-bloggers.com/how-to-perform-a-logistic-regression-in-r/`](http://www.r-bloggers.com/how-to-perform-a-logistic-regression-in-r/)`etc`。

这里给出了对`glm`模型的概要输出的剖析:

```
=>Model information and model convergence status

->Call:

```

call 下面的两行提供了有关用作训练数据的数据集的信息(即`train_set`)、响应和预测变量的标签(分别为`propensity_to_buy`和`Source`)，以及用于拟合的逻辑回归算法的类型(`glm`，或`binary(logit)`族的广义线性模型)。`glm`模型的`maxit`参数给出了拟合模型的迭代次数，这使我们能够确定最大似然估计。

```
->Deviance residuals

```

偏差残差输出是对与`glm`模型中使用的每个数据点相关的计算偏差分布的描述。这是非参数形式的输出。偏差残差是`glm`模型输出的标准残差。

```
->Dispersion parameter for the binomial family is assumed to be 1.

```

默认情况下，GLMs 会打印离差参数，但计数模型会增加更多值。这仅仅意味着二项式家族的离差参数被假定为 1。

```
-> Number of Fisher scoring iterations

```

它给出了用于参数估计的评分模型的类型，以及如何估计该模型。线性模型通常使用输出为封闭形式的可解方程进行估计，但 GLMs 使用迭代方法进行估计。默认情况下使用牛顿-拉夫森方法。这里，该模型使用 Fisher 评分算法进行最大似然估计。

Note

在数值分析中，牛顿法(也称为牛顿-拉夫森法，以艾萨克·牛顿和约瑟夫·拉弗森的名字命名)是一种寻找实值函数根(或零点)的连续更好逼近的方法。这是求根算法的一个例子。这是之前描述的费希尔评分法的替代方法。关于这种方法的进一步讨论可以在 [`www.math.ubc.ca/∼anstee/math104/104newtonmethod.pdf`](http://www.math.ubc.ca/%E2%88%BCanstee/math104/104newtonmethod.pdf) 中找到。

```
=>Table of coefficients

```

系数和有效数。代码给出了协变量的详细信息。

```
->Coefficients

Coefficients:

                Estimate Std. Error z value Pr(>|z|)

(Intercept)    2.857e+01  9.493e+04       0        1

SourceOrigin2 -5.713e+01  1.292e+05       0        1

SourceOrigin3 -1.927e-05  1.420e+05       0        1

    Null deviance: 4.1559e+02  on 309  degrees of freedom

Residual deviance: 2.4340e-10  on 307  degrees of freedom

AIC: 6

```

我们的模型有一个预测值`Source`和截距，称为常数。下面概述了如何分析输出:

在第二行的`Estimate`列下，该值给出了与左侧列出的变量相关的系数。这是如果`Source`增加一个单位(`Source`的值为`Origin2`)，那么`propensity_to_buy`的对数几率将增加的估计值。类似地，第三行`Source`的值为`Origin3`。

第一行给出了`Source`为 00 时`propensity_to_buy`的对数赔率(第二行以上)。对数优势是对`glm`模型中优势比简单预测的解释。

下一列`Std. Error`给出了与这些估计值相关的标准误差(如第二行所示)。这是一个估计，平均来说，如果模型以相同的方式重新运行，但使用新的数据，这些估计会传播多少。将估计值除以标准误差，得到的商被假定为具有足够大估计值的正态分布。该值列在`z value`栏中。最后一列`Pr(>|z|)`列出了与标准正态分布中的 z 值相对应的双尾 p 值。

```
->Significant codes

```

附加的重要代码信息显示为最后一列右侧的星号。此信息跟在系数表正下方的键后面。在我们的例子中，我们看不到这些星星，因为在表`table(train_set$Source`、`train_set$propensity_to_buy`和`table(test_set$Source`、`test_set$p_to_buyPred`中有零值。

```
=> Testing individual parameters

->Wald chi-squared statistics

> library(aod)
Warning message:
package 'aod' was built under R version 3.2.5
> wald.test(b = coef(logitM), Sigma = vcov(logitM), Terms =  1:2)
Wald test:
----------

Chi-squared test:
X2 = 2e-07, df = 2, P(> X2) = 1.0
> wald.test(b = coef(logitM), Sigma = vcov(logitM), Terms =  1:3)
Wald test:
----------

Chi-squared test:
X2 = 2.7e-07, df = 3, P(> X2) = 1.0
> wald.test(b = coef(logitM), Sigma = vcov(logitM), Terms =  2:3)
Wald test:
----------

Chi-squared test:
X2 = 2.6e-07, df = 2, P(> X2) = 1.0

=> Confidence intervals of individual parameters

->Overall goodness-of-fit

```

总体拟合优度由三个指标控制:零偏差、残差偏差和 AIC。

零偏差衡量只有一个截距的模型(没有预测值的简化模型)预测的响应。这是缩小模型的情况。

剩余偏差是由包含预测变量的模型预测的反应。换句话说，这两个给出了`glm`模型的拟合不足；值越低，模型越好。以这种方式，它是拟合优度的度量。

与这两个相关联的自由度的差异仅为 2。在我们的例子中，我们有一个预测器，`Source`；但是它的值 Origin2 和 Origin3 有两个估计值，所以使用了两个额外的自由度。

```
-> AIC

```

AIC 是另一个衡量拟合优度的指标，用来衡量模型与数据的拟合程度。换句话说，这表明模型的成本有多高，基于它必须估计的系数的数量。推荐的型号是 AIC 值较低的型号。在我们的例子中，这个值是 6，可以作为一个合适的模型。

### AUC 曲线

这与 GLM 模式的中华民国有关。它通过评估真阳性率(也称为灵敏度)和假阴性率(也称为 1-特异性)来提供模型的性能特征。考虑到 p > 0.5，ROC 图通过预测 p > 0.5 的所有可能值给出了成功率的最佳方案。曲线下面积，也称为 AUC，是 ROC 曲线的性能指标。AOC 给出了准确性指数或一致性指数。

Note

AOC 越高，模型的预测能力越好。

图 [6-1](#Fig1) 描绘了我们预测购买倾向的逻辑回归模型的 AUC 曲线。给定`Source`的数据值和相应的购买倾向，我们看到 AUC 是一条完美的、翻转的 L 形直角曲线，从 x 轴上的 0 开始，延伸到 y 轴上的 1，然后以直角方式向右弯曲，以 x = 1 值结束。

这是因为我们开始的数据对`Origin1`和`Origin3`的值是 1，对`Origin2`的值是 0，而在`propensity_to_buy`列中对应的值是 1 和 0。并且对于相应的`Source`值，预测的概率也是 1 和 0。

```
=> anova(logitM)

-> Analysis of deviance table

```

R 中的`anova`函数使我们能够通过分析`pf`偏差表来测试因素的影响。在我们的逻辑回归模型中，有一个解释变量和相应的因素，`Source`。`glm`模型符合仅截距模型，输出与零偏差相同的统计数据(低于系数):偏差= 415.59。这由这里的`anova`输出显示:

```
Analysis of Deviance Table

Model: binomial, link: logit

Response: propensity_to_buy

Terms added sequentially (first to last)

       Df Deviance Resid. Df Resid. Dev
NULL                     309     415.59
Source  2   415.59       307       0.00

```

### 使用 ORE SQL 接口实现解决方案

现在我们有了最初的解决方案，我们通过使用 ORE SQL 接口与 OBIEE 12c 集成来实现它。实现这一点的步骤如下:

1.  在 R 脚本存储库中创建一个 R 函数作为脚本，方法是使用`sys.rqScriptCreate`在 Oracle DB 中创建一个输入表来保存葡萄酒源数据以及基于`Source`列的列`propensity_to_buy`。代码如清单 [6-3](#Par121) 所示。

    ```
    begin
    sys.rqScriptDrop('CreateInputTable');
    sys.rqScriptCreate('CreateInputTable',
    'function(dat) {
        library(ORE)
        ore.connect("testr","orcl","localhost","testr")
        setwd("F:/testr")
        dat <- read.csv("Wineptobuy.csv")
        ore.drop(table="WINE_SOURCE_DATA")
        ore.create(dat, table="WINE_SOURCE_DATA")
       }');
    end;
    /

    Listing 6-3.R Script That Creates an Oracle Table Based on the input .csv File

    ```

2.  执行前面的代码，在`testr`模式中创建`WINE_SOURCE_DATA`表。这是使用下面的`select`语句完成的:

    ```
    select * from table (rqEval(NULL, 'XML', 'CreateInputTable'));

    ```

    下面是执行这个`select`语句的输出:

    ```
    ----------------------------------------------------------------------------
    SQL> select * from table (rqEval(NULL, 'XML', 'CreateInputTable'));

    NAME
    ----------------------------------------------------------------------------
    VALUE
    ----------------------------------------------------------------------------

    <root><ANY_obj><ROW-ANY_obj><value></value></ROW-ANY_obj></ANY_obj></root>

    SQL>

    ```

3.  创建一个 R 函数，构建逻辑回归模型，根据葡萄酒来源预测购买倾向，然后根据测试数据对模型进行评分。GLM 的机器学习算法被用于此。该函数与一个 R 脚本相关联，该脚本将保存在 ORE 的 R 脚本存储库中。清单 [6-4](#Par127) 显示了代码。

    ```
    begin
       sys.rqscriptDrop('BuildandScoreptobuy');
       sys.rqScriptcreate('BuildandScoreptobuy',
    'function(table_name) {
    ore.sync(table=table_name)
    ore.attach()
    winedata <- ore.pull(ore.get(table_name))
    winedata$ID <- 1:nrow(winedata)
    sapply(winedata, sd)
    xtabs(∼propensity_to_buy +Source, data=winedata)
    xtabs(∼propensity_to_buy +origin, data=winedata)
    label <- winedata[,23]
    library(caTools)
    s <- sample.split(label, SplitRatio=3/4)
    train_set <- winedata[s, c(2:20, 23)]
    test_set <- winedata[!s, c(2:20, 23)]
    sp.tab <- table(train_set$Source, train_set$propensity_to_buy)
    train_set$Source <- factor(train_set$Source)
    logitM <- glm(propensity_to_buy ∼ Source, data = train_set, family="binomial", control = glm.control(maxit=100))
    library(aod)
    head(data.frame(test_set[,c(1:19)]))
    p_to_buyPred <- predict(logitM,  newdata = data.frame(test_set[,c(1:19)]), type="response")
    p_to_buyPred <- ifelse(p_to_buyPred > 0.5,1,0)
    misClasificError <- mean(p_to_buyPred != test_set$propensity_to_buy)
    p_to_buyPred[as.integer(rownames(p_to_buyPred))] <- p_to_buyPred
    res <- cbind(data.frame(test_set[,c(1:19)]), PRED = p_to_buyPred)
    res1.df <- data.frame(res[,c(1,2,19,20)])
    library(ggplot2)
    gg_plot <- ggplot(data=test_set, aes(x=Source, y=p_to_buyPred, group=1)) +
    geom_line(aes(colour = p_to_buyPred), size = 1) + geom_point() +
    stat_smooth(method="glm", family="binomial", se=FALSE) +
    ggtitle("Predicting Propensity to buy based on Wine Source") +
    labs(x="Source", y="Predicted Probability - p_to_buyPred")
    plot(gg_plot)
    res1.df
    }');
    end;
    /

    Listing 6-4.GLM-Based Logistic Regression Model to Build and Score the Propensity to Buy Based on the Wine Source

    ```

4.  创建一个 R 函数，调用前面的`BuildandScoreptobuy`函数，在通过列出 Oracle 12c DB 生成的 ORE 引擎中执行它，以输出基于葡萄酒来源的购买倾向的预测概率。清单 [6-5](#Par129) 显示了代码。

    ```
    begin
    sys.rqScriptDrop('CallPtoBuy');
    sys.rqScriptCreate('CallPtoBuy',
    'function(dat, input_table_name) {
        input_table_name <- "WINE_SOURCE_DATA"
        ore.scriptLoad(name = "BuildandScoreptobuy")
        res1 <- BuildandScoreptobuy(input_table_name)
        res1.df <- data.frame(res1)
        res1.df
       }');
    end;
    /

    Listing 6-5.R Function That Calls the BuildandScoreptobuy Function
    to Output Predicted Probability of Propensity to Buy Based on the Source

    ```

    清单 [6-5](#Par129) 中的代码可以通过使用 ORE SQL 接口以多种方式执行，以输出 XML、单个列或 PNG 图像图形。下面的`SELECT`陈述表明这是可以做到的:
    1.  输出 XML:获取集成图的 XML 输出的初始 SQL `SELECT`如下:

        ```
        select * from table(rqTableEval(cursor(select * from WINE_SOURCE_DATA),
        cursor(select 1 as "ore.connect", 'WINE_SOURCE_DATA' as "input_table_name" from dual),
        'XML',
        'CallPtoBuy'));

        ```

        输出可以临时准备，以便在从 Internet Explorer 或其他 XML 显示软件打开时显示为 XML。下面的查询实现了这一点:

        ```
        select xmltype(a.value).getClobVal() as "XML Output with image included"
        from table(rqTableEval(cursor(select * from WINE_SOURCE_DATA),
        cursor(select 1 as "ore.connect", 'WINE_SOURCE_DATA' as "input_table_name" from dual),
        'XML',
        'CallPtoBuy')) a;

        ```

        ![A439668_1_En_6_Figa_HTML.jpg](A439668_1_En_6_Figa_HTML.jpg) ![A439668_1_En_6_Figb_HTML.jpg](A439668_1_En_6_Figb_HTML.jpg) ![A439668_1_En_6_Figc_HTML.jpg](A439668_1_En_6_Figc_HTML.jpg) ![A439668_1_En_6_Figd_HTML.jpg](A439668_1_En_6_Figd_HTML.jpg)
    2.  输出单个列:

        ```
        SQL> select * from table(rqTableEval(cursor(select * from WINE_SOURCE_DATA),
          2  cursor(select 1 as "ore.connect", 'WINE_SOURCE_DATA' as "input_table_name" from dual),
          3  'select "origin", "class","Source", 1 "PRED" from WINE_SOURCE_DATA a',
          4  'CallPtoBuy'));

        origin
        ----------------------------------------------------------------------------
             class
        ----------
        Source
        ----------------------------------------------------------------------------
              PRED
        ----------
        Origin1
                 1
        Origin1
                 1

        Origin1
                 1
        Origin1
                 1

        Origin1
                 1
        Origin1
                 1

        Origin1
                 1
        Origin1
                 1

        Origin1
                 1
        Origin1
                 1

        Origin1
                 1
        Origin1
                 1

        Origin1
                 1
        Origin1
                 1

        Origin1
                 1
        Origin1
                 1

        Origin1
                 1
        Origin1
                 1

        Origin1
                 1
        Origin1
                 1

        Origin1
                 1
        Origin1
                 1

        Origin1
                 1
        Origin1
                 1

        Origin1
                 1
        Origin1
                 1

        Origin1
                 1
        Origin1
                 1

        Origin1
                 1
        Origin1
                 1

        Origin1
                 1
        Origin1
                 1

        Origin2
                 2
        Origin2
                 0

        Origin2
                 2
        Origin2
                 0

        ......

        103 rows selecte

        d.

        ```

    3.  输出 PNG 图形:

        ```
        SQL>select id, image from table(rqTableEval(cursor(select * from WINE_SOURCE_DATA),
           cursor(select 1 as "ore.connect", 'WINE_SOURCE_DATA' as "input_table_name" from dual),
            'PNG',
            'CallPtoBuy'));

        SQL> select id, image from table(rqTableEval(cursor(select * from WINE_SOURCE_DATA),
          2     cursor(select 1 as "ore.connect", 'WINE_SOURCE_DATA' as "input_table_name" from dual),
          3      'PNG',
          4      'CallPtoBuy'));

                ID
        ----------
        IMAGE
        ----------------------------------------------------------------------------
                 1
        89504E470D0A1A0A0000000D49484452000001E0000001E008060000007DD4BE9500002000494441
        54789CECDD6B701BE79A27F67F032078274851574A962C8B775D6C89B22D03E3736AB333734269C5
        28991AED566EAA64CBD4EC4C2AD497A3DA0FA7E6A476BDB5159F9A1D22134FAD349BA9782A959495
        AA73142922D7D94A65667C08D19628DBBA5014015D2D93922551BCDF00F49B0F4D800DB0890B8946
        77A3FFBF2A9648400D3CB8F583F7F6BC92104280888888F2CA61740044444476C4044C4444640026
        60222222033001EB2C140A191D42C158CF73C9D78188CCC6D209589224CD9FDEDEDE9CDE4F6F6F2F
        24494AB8DF4C4EE83E9F0F57AE5CC9FAB8B5C8D773914FEAE72BF9B9CCC67A8E8DC591AFE7D14CAF
        59F2FB5E4FA74F9FC6E9D3A735EFDFEFF7275CEEF7FBE1F3F900E8FB998AC5A5FE3C25C748B41E96
        4EC000D0D3D3032144FCA7A7A707478F1ED5F5432984407D7D7DDE8ECB9411CF859EF47EBEC83C5A
        5B5B71FBF6ED84CB2E5EBC88CECE4E0C0E0E265C7EE1C2059C3C791280BEEF9158B2557FA66EDFBE
        CD244CB9232C0C80E8E9E95971B9D7EB15DDDDDD09BF0310004430188C5F1EBBCCEBF56ADE76EC27
        76BCFABAD8ED048341CDDB51DF7E6767E78AE362B1ABEF27765D2631E4EBB9D08A53EB3EB2395EFD
        38D5F1245F17FB3BF9B98CFDA8757777AFB82C3936F5F5E95EFFE4C7901CA7D6638C893D5E214456
        B166725FEAF75BEC477DDFA99ECF4C1E7736EFB974B797C97B3CF97125DFB6D6E5C99FA36C3E53D9
        BEEEC9C7AB5FDB6C9E83D58ED7FA4CAE764E59CB6320732BD8041CBBDCEBF5AE7893AA939210CA49
        2B3979AAAF4F3E116A7DE8B58ED3BA1DF571EADBECECEC4C882176021422F1A4ABC773A14E065A71
        A8EF37F9A49CEEB94CF538934F46C97F277F4988DDCF6A2741ADC7AF1563BAC79C2CDD7390EA249B
        6DACD9DE576767E7AAF7B5DAC95E7DDBD9BCEF9365FBDE49F73CAB9F97D8172FADCB537D1653DD5F

        BAC79FEEF165F27FB49E8374093855D24E774E49F718C8DC0A2E01C7DEE05A276EF5F5C9621F72AD

        EB574B0CABDD96FA365325E05427EDE40FD55A5AC0E99E0BADD645F26D69DD6EECB274CF65268F33
        DD635A2D76F5EDAEF638D4F1247F9949F59833B92ED573A4F57EC934D674F7952CD3E73317EF7BB5
        B5BC77D2BDDE9D9D9D095FB262BF77777727FCAE4E78D97CA6D2BD57B5A85BD3C99FC95C3C07999E
        9FD6F318C8BC2C3F067CF4E8D1844912478F1E4530184C18176A6C6C8CFF3E3C3C0C60E5A4A54020
        80E1E1610C0F0FC3EBF526DC47434383E67D6BFDDF5C181E1EC6BE7DFB122E533F86D564FB5C0483
        41CDF8BD5E6FFC7902563EFED8F5E99ECB74DADBDBE1F57AD73461ACB3B313172F5E04005CB97205
        9D9D9D191D97E9634EB6DA73A047AC99DC97FA358E49F57CE6F27D0FACFD794CE5C48913F1F1DE8B
        172FC6DFABC78E1DC3850B1700008383833871E244D6B7BDD6F7AA508DFF060281848958B97A0E92
        CF4FAB9D53D6FB7923F3B17C024E9E7824329894E1F57A571C2384405757579EA2D6C75A9E8BF55A
        EF73D9D7D70721043A3B3BE35F20329934F6F39FFF1CE7CF9F07A04CCA59CB49395F72196BECA4DB
        DDDD1D9F68A796EAF934FBFBBEA1A121FE3C9D3F7F1EEDEDED0080FAFA7A04020100C0EDDBB7537E
        314865BD8F5F0881603088F3E7CF1B36B1D1ECAF2165C7F209385B8D8D8DF10F73A6D70783C135DD
        D65A353636AE9811AAC737DC868606CDF80381C08A96B2D6F5B97CFCE7CE9D8310025EAF37A32543

        F5F5F5F07ABDF0FBFD080402F193753A993EE664AB3D0799C836D6D5EEABB7B7377E024E77C24D7E

        3E73F9BE07D6FE3CA6127B9E628F53ADB3B333BE1C692D5F2AB37DAFAEB6042B76DFC1605097E720
        559C7A9D6FC8403A756DE705528C8DC5688D8F244F7CD01A2B4D1E67523F555865DC29797C6AAD63
        C0AB1D9BEAE55ACF73B19E8934E99ECB548F33F931C7C6D4B466B8263F1F422C8F8B673251269793
        B0B49E03AD19D66B8935D57DADF67CC59EA774CFE77ADFF7C9D63B01494BEC36B45E6BADCBB3FD4C
        A57AFC5A8F2FDD5C8C74CF41BAF786D66732DD39259BC740E666CB041CBB3C7682D17A03ABAFCF74
        1952BA936E36278BD8FF51C7902E49E4E2B9D09A91199B69AB757DF2F1C9CF65BAC7A9BEEDE4FFAB
        BE2DAD04167BEED33D6EAD63533DE664B1FB48F5FF931F43F26B9969ACE9EE2BF9F9521FA375BDD6
        17AEB5BEEFB5A47BEF649B8063FF2739EED59EBF6C3F53E91E7FB2E4E733DDFB3FDBF786D66732D5
        39652D8F81CC4B12420890E9F5F6F6E2E38F3F465F5F5F5EEF579224F4F4F464DCC59B4FA150080D
        0D0DB0C25BD84AB112517ED86E0CD80A62E34FEA891E1F7FFC71BCFA0F29AE5CB982EEEE6EA3C3C8
        88956225A2FC70191D00ADD4DEDE8EEEEEEE84D99EDDDDDD9CE9B824D69AF47ABD79EF11C8969562
        25A2FC62173411119101D8054D444464002660222222033001131111198009988888C8004CC04444
        44066002262222328025D701CBB28CD7AF5F1B1D46DE6DD8B001737373989B9B333A144A525D5D8D
        70388C999919A343A1245555551042606A6ACAE850F2AEB6B6D6E81028054B266000B62DE92796B6
        1F2373E26B635E7C6DC86CD8054D444464002660222222033001131111198009988888C8004CC044
        4444066002262222320013301111910198808988880CC0044C444464002660222222033001131111
        198009988888C8004CC044444406600226222232405E12F0E5CB97313030A079DDD9B367D1D1D181
        4F3FFD34E5...... 

        ```

当运行前面的`SELECT`语句并在 Oracle SQL Developer 中查看其输出时，我们会得到如图 [6-7](#Fig7) 所示的图表。该图基于绘制来源与预测概率(`p_to_buyPred`)的 ggplot 图。

![A439668_1_En_6_Fig7_HTML.jpg](A439668_1_En_6_Fig7_HTML.jpg)

图 6-7。

PNG output of the logistic regression model to predict propensity to buy wine based on its source

我们对 GLM 机器学习算法感兴趣的另一个图形是 AUC 曲线。该代码如清单 [6-6](#Par146) 所示。

```
begin
--   sys.rqscriptDrop('BuildandScoreptobuyAUC');
   sys.rqScriptcreate('BuildandScoreptobuyAUC',
'function(table_name) {
ore.sync(table=table_name)
ore.attach()
winedata <- ore.pull(ore.get(table_name))
winedata$ID <- 1:nrow(winedata)
sapply(winedata, sd)
xtabs(∼propensity_to_buy +Source, data=winedata)
xtabs(∼propensity_to_buy +origin, data=winedata)
label <- winedata[,23]
library(caTools)
s <- sample.split(label, SplitRatio=3/4)
train_set <- winedata[s, c(2:20, 23)]
test_set <- winedata[!s, c(2:20, 23)]
sp.tab <- table(train_set$Source, train_set$propensity_to_buy)
train_set$Source <- factor(train_set$Source)
logitM <- glm(propensity_to_buy ∼ Source, data = train_set, family="binomial", control = glm.control(maxit=100))
library(aod)
head(data.frame(test_set[,c(1:19)]))
p_to_buyPred <- predict(logitM,  newdata = data.frame(test_set[,c(1:19)]), type="response")
p_to_buyPred <- ifelse(p_to_buyPred > 0.5,1,0)
misClasificError <- mean(p_to_buyPred != test_set$propensity_to_buy)
p_to_buyPred[as.integer(rownames(p_to_buyPred))] <- p_to_buyPred
res <- cbind(data.frame(test_set[,c(1:19)]), PRED = p_to_buyPred)
res1.df <- data.frame(res[,c(1,2,19,20)])
library(ROCR)
pr1 <- prediction(p_to_buyPred, test_set$propensity_to_buy)
class(pr1)
prf1 <- performance(pr1, measure = "tpr", x.measure = "fpr")
class(prf1)
plot(prf1, colorize = TRUE) # , text.adj = c(-0.2,1.7)
res1.df
}');
end;
/

Listing 6-6.GLM-Based Logistic Regression Model

to Build and Score Propensity to Buy Based on Wine Source That Plots the AUC Curve

```

调用这个 R 函数的代码如清单 [6-7](#Par148) 所示。

```
begin
sys.rqScriptDrop('CallPtoBuyAUC');
sys.rqScriptCreate('CallPtoBuyAUC',
'function(dat, input_table_name) {
    input_table_name <- "WINE_SOURCE_DATA"
    ore.scriptLoad(name = "BuildandScoreptobuyAUC")
    res1 <- BuildandScoreptobuyAUC(input_table_name)
    res1.df <- data.frame(res1)
    res1.df
   }');
end;
/

Listing 6-7.Code for Calling the BuildandScoreptobuyAUC

```

执行下面的`SELECT`语句调用清单 [6-7](#Par148) 中的函数，给出如图 [6-8](#Fig8) 所示的图形。

```
select * from table(rqTableEval(cursor(select * from WINE_SOURCE_DATA),
cursor(select 1 as "ore.connect", 'WINE_SOURCE_DATA' as "input_table_name" from dual),
 'PNG',
 'CallPtoBuyAUC'));

```

AUC 显示一个倒 L 形，这意味着建立和评分的 GML 模型对于上下文中的数据是理想的。面积越大，模型越完善。

![A439668_1_En_6_Fig8_HTML.jpg](A439668_1_En_6_Fig8_HTML.jpg)

图 6-8。

PNG output of the logistic regression model shows the AUC for predicting wine propensity to buy based on its source

## 将 PNG 输出与 OBIEE 仪表板集成

按照第 [3](3.html) 章“将 PNG 图形与 OBIEE 集成”小节中概述的步骤，图 [6-7](#Fig7) 所示的 PNG 图像可以与 OBIEE 集成。一旦集成了映像，就可以在 OBIEE 中创建分析和后续仪表板。这里我们列出了涉及的主要步骤；第 [3](3.html) 章已经提供了一些步骤。：

1.  Create a new physical table of type `SELECT` in the Physical layer (using the OBIEE RPD downloaded from the WebLogic server and opening it offline in the BI Administration Tool). We already have the connection pool created from Chapter [3](3.html). The query used to generate the PNG output of the machine-learning algorithm for logistic regression is used as the initialization string value for the `SELECT`-type table. This is shown in Figure [6-9](#Fig9). This new table is named `CallPtoBuy`. The RPD can be downloaded using the following command:

    ![A439668_1_En_6_Fig9_HTML.jpg](A439668_1_En_6_Fig9_HTML.jpg)

    图 6-9。

    Physical table properties cre ated in OBIEE RPD for the Propensity to Buy PNG graph to be integrated with OBIEE12c

    ```
    datamodel.cmd downloadrpd -O obieenew.rpd -W Admin123 -U weblogic -P <password> -SI ssi -S localhost -N 9502 -Y

    ```

2.  Add the new table to the Business Mapping and Modeling layer. The dialog boxes in Figures [6-10](#Fig10) and [6-11](#Fig11) show the logical column properties and the expression to be built for the `ID` column and the `IMAGE` column.

    ![A439668_1_En_6_Fig11_HTML.jpg](A439668_1_En_6_Fig11_HTML.jpg)

    图 6-11。

    Logical expression to be specified for the ID column that includes both the ID and IMAGE column

    ![A439668_1_En_6_Fig10_HTML.jpg](A439668_1_En_6_Fig10_HTML.jpg)

    图 6-10。

    Logical column ID properties The logical expression looks like the following:

    ```
    lookup("orcl_db".""."TESTR"."CallPtoBuy"."IMAGE", "orcl_db".""."TESTR"."CallPtoBuy"."ID")

    ```

3.  需要使用以下命令将修改后的 RPD 上传到 WebLogic server:

    ```
    datamodel.cmd uploadrpd -I obieenew08062017.rpd -W Admin123 -U weblogic -P <password> -SI ssi -S localhost -N 9502
    Service Instance: ssi

    Operation successful.
    RPD upload completed successfully.

    ```

4.  重新启动 WebLogic Server。
    1.  使用 URL `localhost:9502/analytics`登录 OBIEE12c。
    2.  单击管理➤维护和故障排除。
    3.  然后单击重新加载文件和元数据。
    4.  在分析和 Interactive Reporting 下，单击分析。
    5.  选择 TESTR 主题区域。
    6.  在标准选项卡中展开`CallPtoBuy`。然后将所选列区域下的`ID`和`IMAGE`列拖放到其右侧。
    7.  Click Results.

        ![A439668_1_En_6_Fig14_HTML.jpg](A439668_1_En_6_Fig14_HTML.jpg)

        图 6-14。

        Dashboard showing the pairs plot of predicting wine origin and using it to predict the propensity to buy

        ![A439668_1_En_6_Fig13_HTML.jpg](A439668_1_En_6_Fig13_HTML.jpg)

        图 6-13。

        Output graph of wine so urce vs. predicted Probability based on machine-learning GLM algorithm executed in ORE and integrated with OBIEE 12c

        ![A439668_1_En_6_Fig12_HTML.jpg](A439668_1_En_6_Fig12_HTML.jpg)

        图 6-12。

        Output graph of wine source vs. predicted probability based on machine-learning GLM algorithm executed in ORE and integrated with OBIEE 12c  
    8.  Sour ce 与预测概率(`ptobuyPred`)的关系图如图 [6-12](#Fig12) 和 [6-13](#Fig13) 所示。 

图 [6-14](#Fig14) 显示了最终的仪表板，显示了预测葡萄酒产地然后利用产地预测购买倾向的概率图。

## 摘要

本章讲述了机器学习在 OBIEE 12c 中的实现。从对业务问题和解决方案的简要描述开始，它详细介绍了如何使用基于 GLM 模型的逻辑回归机器学习算法来预测基于原产地的葡萄酒购买倾向。本章随后通过 XML、结构化表格结果和 PNG 图展示了模型输出的各种选项。最后，它概述了如何将 PNG 图像与 OBIEE 仪表板集成，并与葡萄酒原产地预测图合并，以生成并排显示两者的最终仪表板。必要时提供可执行代码及其执行输出。